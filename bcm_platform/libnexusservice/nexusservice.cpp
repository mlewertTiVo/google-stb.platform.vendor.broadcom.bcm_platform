/******************************************************************************
 *    (c)2010-2014 Broadcom Corporation
 * 
 * This program is the proprietary software of Broadcom Corporation and/or its licensors,
 * and may only be used, duplicated, modified or distributed pursuant to the terms and
 * conditions of a separate, written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized License, Broadcom grants
 * no license (express or implied), right to use, or waiver of any kind with respect to the
 * Software, and Broadcom expressly reserves all rights in and to the Software and all
 * intellectual property rights therein.  IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU
 * HAVE NO RIGHT TO USE THIS SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY
 * NOTIFY BROADCOM AND DISCONTINUE ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization, constitutes the valuable trade
 * secrets of Broadcom, and you shall use all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" 
 * AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES, REPRESENTATIONS OR 
 * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO 
 * THE SOFTWARE.  BROADCOM SPECIFICALLY DISCLAIMS ANY AND ALL IMPLIED WARRANTIES 
 * OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, 
 * LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION 
 * OR CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT OF 
 * USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR ITS 
 * LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR 
 * EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO YOUR 
 * USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF 
 * THE POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF THE AMOUNT 
 * ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE 
 * LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF ESSENTIAL PURPOSE OF 
 * ANY LIMITED REMEDY.
 *
 * $brcm_Workfile: nexusservice.cpp $
 * 
 *****************************************************************************/
  
//#define LOG_NDEBUG 0

#include <utils/Log.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <unistd.h>

#include <string.h>
#include <cutils/atomic.h>
#include <utils/Errors.h>
#include <binder/IServiceManager.h>
#include <utils/String16.h>
#include <utils/Vector.h>
#include "cutils/properties.h"

#include "nexusservice.h"
#if NEXUS_HAS_CEC
#include "nexuscecservice.h"
#endif

#include "nexus_audio_mixer.h"
#include "nexus_audio_decoder.h"
#include "nexus_audio_playback.h"
#include "nexus_video_decoder_extra.h"
#include "nexus_base_mmap.h"

extern "C" {
#include "namevalue.h"
#include "namevalue.inc"
}

#include "nexus_ipc_priv.h"

#ifdef LOG_TAG
#undef LOG_TAG
#endif
#define LOG_TAG "NexusService"

#ifdef UINT32_C
#undef UINT32_C
#define UINT32_C(x)  (x ## U)
#endif

/* The main heap normally has full access */
#ifdef NEXUS_PLATFORM_DEFAULT_HEAP
#define NEXUS_MAIN_HEAP_IDX NEXUS_PLATFORM_DEFAULT_HEAP
#else
#define NEXUS_MAIN_HEAP_IDX NEXUS_MEMC0_MAIN_HEAP
#endif 

BDBG_OBJECT_ID(NexusClientContext);

#if ANDROID_ENABLE_HDMI_HDCP
#include "nexus_hdmi_output.h"
#include "nexus_hdmi_output_hdcp.h"

/*****************/
/* For HDCP TESTING */
/* 1) insert the Production Key Set set generated by BCrypt */
/* 2) set the USE_PRODUCTION_KEYS macro to to 1 */
/*****************/
#define USE_PRODUCTION_KEYS 0
#if USE_PRODUCTION_KEYS
/*****************************/
/* INSERT PRODUCTION KeySet HERE */
/*****************************/
#else
/**************************************/
/* HDCP Specification Test Key Set */
/* */
/* NOTE: the default declared Test */
/* KeySet below is from the HDCP Spec */
/* and it *IS NOT* compatible with */
/* production devices */
/**************************************/

static NEXUS_HdmiOutputHdcpKsv hdcpTxAksv =
{ {0x14, 0xF7, 0x61, 0x03, 0xB7} };

static NEXUS_HdmiOutputHdcpKey encryptedTxKeySet[NEXUS_HDMI_OUTPUT_HDCP_NUM_KEYS] =
{
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x691e138f, 0x58a44d00},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x0950e658, 0x35821f00},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x0d98b9ab, 0x476a8a00},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xcac5cb52, 0x1b18f300},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xb4d89668, 0x7f14fb00},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x818f4878, 0xc98be000},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x412c11c8, 0x64d0a000},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x44202428, 0x5a9db300},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x6b56adbd, 0xb228b900},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xf6e46c4a, 0x7ba49100},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x589d5e20, 0xf8005600},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xa03fee06, 0xb77f8c00},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x28bc7c9d, 0x8c2dc000},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x059f4be5, 0x61125600},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xcbc1ca8c, 0xdef07400},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x6adbfc0e, 0xf6b83b00},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xd72fb216, 0xbb2ba000},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x98547846, 0x8e2f4800},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x38472762, 0x25ae6600},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xf2dd23a3, 0x52493d00},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x543a7b76, 0x31d2e200},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x2561e6ed, 0x1a584d00},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xf7227bbf, 0x82603200},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x6bce3035, 0x461bf600},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x6b97d7f0, 0x09043600},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xf9498d61, 0x05e1a100},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x063405d1, 0x9d8ec900},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x90614294, 0x67c32000},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xc34facce, 0x51449600},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x8a8ce104, 0x45903e00},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xfc2d9c57, 0x10002900},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x80b1e569, 0x3b94d700},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x437bdd5b, 0xeac75400},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xba90c787, 0x58fb7400},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xe01d4e36, 0xfa5c9300},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xae119a15, 0x5e070300},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x01fb788a, 0x40d30500},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xb34da0d7, 0xa5590000},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x409e2c4a, 0x633b3700},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x412056b4, 0xbb732500}
} ;
#endif

/*
  from HDCP Spec:
  Table 51 gives the format of the HDCP SRM. All values are stored in big endian format.

  Specify KSVs here in big endian;
*/
#define NUM_REVOKED_KSVS 3
static uint8_t NumRevokedKsvs = NUM_REVOKED_KSVS ;
static const NEXUS_HdmiOutputHdcpKsv RevokedKsvs[NUM_REVOKED_KSVS] =
{
    /* MSB ... LSB */
    {{0xa5, 0x1f, 0xb0, 0xc3, 0x72}},
    {{0x65, 0xbf, 0x04, 0x8a, 0x7c}},
    {{0x65, 0x65, 0x1e, 0xd5, 0x64}}
} ;

void NexusService::hdmiOutputHdcpStateChangedCallback(void *pContext, int param __unused)
{
    bool success = false ;
    NEXUS_HdmiOutputHandle handle = (NEXUS_HdmiOutputHandle)pContext;
    NEXUS_HdmiOutputHdcpStatus hdcpStatus;

    NEXUS_HdmiOutput_GetHdcpStatus(handle, &hdcpStatus);

    switch (hdcpStatus.hdcpError) {
    case NEXUS_HdmiOutputHdcpError_eSuccess :
        LOGE("HDCP Authentication Successful\n");
        success = true ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eRxBksvError :
        LOGE("HDCP Rx BKsv Error") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eRxBksvRevoked :
        LOGE("HDCP Rx BKsv/Keyset Revoked") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eRxBksvI2cReadError :
    case NEXUS_HdmiOutputHdcpError_eTxAksvI2cWriteError :
        LOGE("HDCP I2C Read Error") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eTxAksvError :
        LOGE("HDCP Tx Aksv Error") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eReceiverAuthenticationError :
        LOGE("HDCP Receiver Authentication Failure") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eRepeaterAuthenticationError :
    case NEXUS_HdmiOutputHdcpError_eRepeaterLinkFailure : /* Repeater Error; unused */
        LOGE("HDCP Repeater Authentication Failure") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eRxDevicesExceeded :
        LOGE("HDCP Repeater MAX Downstram Devices Exceeded") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eRepeaterDepthExceeded :
        LOGE("HDCP Repeater MAX Downstram Levels Exceeded") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eRepeaterFifoNotReady :
        LOGE("Timeout waiting for Repeater") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eRepeaterDeviceCount0 : /* unused */
        break ;

    case NEXUS_HdmiOutputHdcpError_eLinkRiFailure :
        LOGE("HDCP Ri Integrity Check Failure") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eLinkPjFailure :
        LOGE("HDCP Pj Integrity Check Failure") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eFifoUnderflow :
    case NEXUS_HdmiOutputHdcpError_eFifoOverflow :
        LOGE("Video configuration issue") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eMultipleAnRequest : /* Should not reach here; but flag if occurs */
        LOGE("Multiple Authentication Request... ") ;

    default :
        LOGE("Unknown HDCP Authentication Error %d", hdcpStatus.hdcpError) ;
    }

    if (!success) {
        LOGE("\nHDCP Authentication Failed. Current State %d\n", hdcpStatus.hdcpState);
        /* always retry */
        NEXUS_HdmiOutput_StartHdcpAuthentication(handle);
    }
}
#endif // ANDROID_ENABLE_HDMI_HDCP

typedef struct NexusClientContext {
    BDBG_OBJECT(NexusClientContext)
    BLST_D_ENTRY(NexusClientContext) link;
    struct {
        NEXUS_ClientHandle nexusClient;
        unsigned connectId;
    } ipc;
    b_refsw_client_client_info info;
    b_refsw_client_client_configuration createConfig;
} NexusClientContext;

NexusServerContext::NexusServerContext() : mLock(Mutex::SHARED), mJoinRefCount(0)
{
    LOGV("%s: called", __PRETTY_FUNCTION__);
    BLST_D_INIT(&clients);
    lastId.client = 0;
}

const String16 INexusService::descriptor(NEXUS_INTERFACE_NAME);

String16 INexusService::getInterfaceDescriptor() {
        return INexusService::descriptor;
}

NEXUS_ClientHandle NexusService::getNexusClient(unsigned pid, const char * name)
{
    NEXUS_PlatformObjectInstance *objects = NULL;
    NEXUS_ClientHandle nexusClient = NULL;
    NEXUS_InterfaceName interfaceName;
    unsigned num = 16; /* starting size. */
    unsigned max_num = 1024; /* some big value. */
    unsigned i, cached_num;
    int rc;

    NEXUS_Platform_GetDefaultInterfaceName(&interfaceName);
    strcpy(interfaceName.name, "NEXUS_Client");
    do {
        cached_num = num;
        if (objects != NULL) {
           BKNI_Free(objects);
        }
        objects = (NEXUS_PlatformObjectInstance *)BKNI_Malloc(num*sizeof(NEXUS_PlatformObjectInstance));
        if (objects == NULL) {
            LOGE("%s: FATAL: Could not allocate memory to hold %d Nexus platform objects!!!", __FUNCTION__, num);
            BDBG_ASSERT(false);
        }
        rc = NEXUS_Platform_GetObjects(&interfaceName, objects, num, &num);
        LOGV("%s: NEXUS_Platform_GetObjects returned %d objects [rc=%d]", __FUNCTION__, num, rc);
        if (rc == NEXUS_PLATFORM_ERR_OVERFLOW) {
            if (num > max_num) {
               rc = NEXUS_SUCCESS;
               num = 0;
               LOGW("%s: NEXUS_Platform_GetObjects overflowed - giving up...", __FUNCTION__);
            } else if (num <= cached_num) {
               num = 2 * cached_num;
               LOGW("%s: NEXUS_Platform_GetObjects overflowed - retrying with %d (was %d)...", __FUNCTION__, num, cached_num);
            }
        }
    } while (rc == NEXUS_PLATFORM_ERR_OVERFLOW);

    for (i=0; i < num; i++) {
        NEXUS_ClientStatus status;
        unsigned j;
        rc = NEXUS_Platform_GetClientStatus(reinterpret_cast<NEXUS_ClientHandle>(objects[i].object), &status);
        if (rc) continue;

        if (status.pid == pid) {
            nexusClient = reinterpret_cast<NEXUS_ClientHandle>(objects[i].object);
            LOGV("%s: Found client \"%s\" with PID %d nexus_client %p.", __PRETTY_FUNCTION__,
                name ? name : "[unnamed]", pid, (void *)nexusClient);
            break;
        }
    }

    if (objects != NULL) {
       BKNI_Free(objects);
    }
    return nexusClient;
}

int NexusService::platformInitAudio(void)
{
    int i;
    int rc = 0;
    NEXUS_PlatformConfiguration            *pPlatformConfig;
    NEXUS_AudioPlaybackOpenSettings         simpleAudioDecoderOpenSettings;
    NEXUS_SimpleAudioDecoderServerSettings  simpleAudioDecoderSettings;
    NEXUS_SimpleAudioPlaybackServerSettings simpleAudioPlaybackSettings;
    NEXUS_AudioDecoderOpenSettings          audioDecoderOpenSettings;

    pPlatformConfig = reinterpret_cast<NEXUS_PlatformConfiguration *>(BKNI_Malloc(sizeof(*pPlatformConfig)));
    if (pPlatformConfig == NULL) {
        ALOGE("%s: Could not allocate enough memory for the platform configuration!!!", __FUNCTION__);
        return NEXUS_OUT_OF_SYSTEM_MEMORY;
    }
    NEXUS_Platform_GetConfiguration(pPlatformConfig);

    /* create audio decoders */
    for (i=0; i<MAX_AUDIO_DECODERS; i++) {
        NEXUS_AudioDecoder_GetDefaultOpenSettings(&audioDecoderOpenSettings);
        audioDecoderOpenSettings.fifoSize = AUDIO_DECODER_FIFO_SIZE;
        audioDecoderOpenSettings.type     = NEXUS_AudioDecoderType_eDecode;
        audioDecoder[i] = NEXUS_AudioDecoder_Open(i, &audioDecoderOpenSettings);
        if (audioDecoder[i] == NULL) {
            LOGE("%s: Could not open audio decoder %d!!!", __PRETTY_FUNCTION__, i);
            BKNI_Free(pPlatformConfig);
            return NEXUS_UNKNOWN;
        }
    }
    
    /* open audio mixer */
    mixer = NEXUS_AudioMixer_Open(NULL);
    if (mixer == NULL) {
        LOGE("%s: Could not open audio mixer!!!", __PRETTY_FUNCTION__);
        BKNI_Free(pPlatformConfig);
        return NEXUS_UNKNOWN;
    }

    NEXUS_AudioPlayback_GetDefaultOpenSettings(&simpleAudioDecoderOpenSettings);
    simpleAudioDecoderOpenSettings.heap = pPlatformConfig->heap[NEXUS_MAIN_HEAP_IDX]; /* eFull mapping */

    /* open the audio playback */
    for (i=0; i<MAX_AUDIO_PLAYBACKS; i++) {
        audioPlayback[i] = NEXUS_AudioPlayback_Open(i, &simpleAudioDecoderOpenSettings);
        if (audioPlayback[i] == NULL) {
            LOGE("%s: Could not open audio playback %d!!!", __PRETTY_FUNCTION__, i);
            BKNI_Free(pPlatformConfig);
            return NEXUS_UNKNOWN;
        }
    }

    /* Connect audio inputs to the mixer and mixer to the outputs */
    if (MAX_AUDIO_DECODERS > 0) {
        rc = NEXUS_AudioMixer_AddInput(mixer, NEXUS_AudioDecoder_GetConnector(audioDecoder[0], NEXUS_AudioDecoderConnectorType_eStereo));
        if (rc) {
            LOGE("%s: Could not add audio decoder 0 to audio mixer!!!", __PRETTY_FUNCTION__);
            BKNI_Free(pPlatformConfig);
            return NEXUS_UNKNOWN;
        }
        if (MAX_AUDIO_DECODERS > 1) {
            rc = NEXUS_AudioMixer_AddInput(mixer, NEXUS_AudioDecoder_GetConnector(audioDecoder[1], NEXUS_AudioDecoderConnectorType_eStereo));
            if (rc) {
                LOGE("%s: Could not add audio decoder 1 to audio mixer!!!", __PRETTY_FUNCTION__);
                BKNI_Free(pPlatformConfig);
                return NEXUS_UNKNOWN;
            }
        }
    }
    
    if (MAX_AUDIO_PLAYBACKS > 0) {
        rc = NEXUS_AudioMixer_AddInput(mixer, NEXUS_AudioPlayback_GetConnector(audioPlayback[0]));
        if (rc) {
            LOGE("%s: Could not add audio playback 0 to audio mixer!!!", __PRETTY_FUNCTION__);
            BKNI_Free(pPlatformConfig);
            return NEXUS_UNKNOWN;
        }
        if (MAX_AUDIO_PLAYBACKS > 1) {
            rc = NEXUS_AudioMixer_AddInput(mixer, NEXUS_AudioPlayback_GetConnector(audioPlayback[1]));
            if (rc) {
                LOGE("%s: Could not add audio playback 1 to audio mixer!!!", __PRETTY_FUNCTION__);
                BKNI_Free(pPlatformConfig);
                return NEXUS_UNKNOWN;
            }
        }
    }

#if NEXUS_NUM_AUDIO_DACS
    rc = NEXUS_AudioOutput_AddInput(NEXUS_AudioDac_GetConnector(pPlatformConfig->outputs.audioDacs[0]), NEXUS_AudioMixer_GetConnector(mixer));
    if (rc) {
        LOGE("%s: Could not add audio mixer to dacs 0 output!!!", __PRETTY_FUNCTION__);
        BKNI_Free(pPlatformConfig);
        return NEXUS_UNKNOWN;
    }
#endif
#if NEXUS_HAS_HDMI_OUTPUT && NEXUS_NUM_HDMI_OUTPUTS
    rc = NEXUS_AudioOutput_AddInput(NEXUS_HdmiOutput_GetAudioConnector(pPlatformConfig->outputs.hdmi[0]), NEXUS_AudioMixer_GetConnector(mixer));
    if (rc) {
        LOGE("%s: Could not add audio mixer to HDMI 0 output!!!", __PRETTY_FUNCTION__);
        BKNI_Free(pPlatformConfig);
        return NEXUS_UNKNOWN;
    }
#endif
#if NEXUS_NUM_SPDIF_OUTPUTS 
    rc = NEXUS_AudioOutput_AddInput(NEXUS_SpdifOutput_GetConnector(pPlatformConfig->outputs.spdif[0]), NEXUS_AudioMixer_GetConnector(mixer));
    if (rc) {
        LOGE("%s: Could not add audio mixer to SPDIF 0 output!!!", __PRETTY_FUNCTION__);
        BKNI_Free(pPlatformConfig);
        return NEXUS_UNKNOWN;
    }
#endif

    /* create simple audio decoder */
    for (i=0; i<MAX_AUDIO_DECODERS; i++) {
        NEXUS_SimpleAudioDecoder_GetDefaultServerSettings(&simpleAudioDecoderSettings);
        simpleAudioDecoderSettings.primary = audioDecoder[i];
#if NEXUS_HAS_HDMI_OUTPUT && NEXUS_NUM_HDMI_OUTPUTS
        simpleAudioDecoderSettings.hdmi.outputs[0] = pPlatformConfig->outputs.hdmi[0];
#endif
        simpleAudioDecoderSettings.stcIndex = i;  /* Must set this to be able to do STC trick modes! */
        simpleAudioDecoder[i] = NEXUS_SimpleAudioDecoder_Create(i, &simpleAudioDecoderSettings);
        if (simpleAudioDecoder[i] == NULL) {
            LOGE("%s: Could not open simple audio decoder %d!!!", __PRETTY_FUNCTION__, i);
            BKNI_Free(pPlatformConfig);
            return NEXUS_UNKNOWN;
        }
    }

    /* create simple audio player */
    for (i=0; i<MAX_AUDIO_PLAYBACKS; i++) {
        NEXUS_SimpleAudioPlayback_GetDefaultServerSettings(&simpleAudioPlaybackSettings);
        simpleAudioPlaybackSettings.decoder = simpleAudioDecoder[i]; /* linked to the audio decoder for StcChannel */
        simpleAudioPlaybackSettings.playback = audioPlayback[i];
        simpleAudioPlayback[i] = NEXUS_SimpleAudioPlayback_Create(i, &simpleAudioPlaybackSettings);
        if (simpleAudioPlayback[i] == NULL) {
            LOGE("%s: Could not open simple audio playback %d!!!", __PRETTY_FUNCTION__, i);
            BKNI_Free(pPlatformConfig);
            return NEXUS_UNKNOWN;
        }
    }
    BKNI_Free(pPlatformConfig);
    return rc;
}

void NexusService::setAudioState(bool enable)
{
    int i;
    NEXUS_SimpleAudioDecoderServerSettings simpleAudioDecoderSettings;
    NEXUS_SimpleAudioPlaybackServerSettings simpleAudioPlaybackSettings;
    
    /* Enable/Disable simple audio player */
    for (i=0; i<MAX_AUDIO_PLAYBACKS; i++) {
        NEXUS_SimpleAudioPlayback_GetServerSettings(simpleAudioPlayback[i], &simpleAudioPlaybackSettings);
        if (enable) {
            simpleAudioPlaybackSettings.decoder = simpleAudioDecoder[i]; /* linked to the audio decoder for StcChannel */
            simpleAudioPlaybackSettings.playback = audioPlayback[i];
        } else {
            simpleAudioPlaybackSettings.decoder = NULL;
            simpleAudioPlaybackSettings.playback = NULL;
        }
        NEXUS_SimpleAudioPlayback_SetServerSettings(simpleAudioPlayback[i], &simpleAudioPlaybackSettings);
    }

    /* Enable/Disable simple audio decoder */
    for (i=0; i<MAX_AUDIO_DECODERS; i++) {
        NEXUS_SimpleAudioDecoder_GetServerSettings(simpleAudioDecoder[i], &simpleAudioDecoderSettings);
        simpleAudioDecoderSettings.enabled = enable;
        NEXUS_SimpleAudioDecoder_SetServerSettings(simpleAudioDecoder[i], &simpleAudioDecoderSettings);
    }
}

void NexusService::hdmiOutputHotplugCallback(void *context __unused, int param __unused)
{
#if NEXUS_HAS_HDMI_OUTPUT
    NEXUS_HdmiOutputStatus       status;
    NEXUS_PlatformConfiguration *pPlatformConfig;
    NEXUS_HdmiOutputHandle       hdmiOutput;
    NEXUS_HdmiOutputSettings     hdmiSettings;
    NexusService *               pNexusService;

    pPlatformConfig = reinterpret_cast<NEXUS_PlatformConfiguration *>(BKNI_Malloc(sizeof(*pPlatformConfig)));
    if (pPlatformConfig == NULL) {
        ALOGE("%s: Could not allocate enough memory for the platform configuration!!!", __FUNCTION__);
    }
    else {
        NEXUS_Platform_GetConfiguration(pPlatformConfig);
        hdmiOutput = pPlatformConfig->outputs.hdmi[param];
        BKNI_Free(pPlatformConfig);

        NEXUS_HdmiOutput_GetStatus(hdmiOutput, &status);

        LOGD("%s: HDMI%d hotplug %s (receive device %s powered)", __func__, param, status.connected ? "connected" : "disconnected", status.rxPowered ? "is" : "isn't");

        /* force HDMI updates after a hotplug */
        NEXUS_HdmiOutput_GetSettings(hdmiOutput, &hdmiSettings) ;
        NEXUS_HdmiOutput_SetSettings(hdmiOutput, &hdmiSettings) ;

        /* restart HDCP if it was previously enabled */
        NEXUS_HdmiOutput_StartHdcpAuthentication(hdmiOutput);

        pNexusService = reinterpret_cast<NexusService *>(context);
        Vector<sp<INexusHdmiHotplugEventListener> >::const_iterator it;

        Mutex::Autolock autoLock(pNexusService->server->mLock);

        for (it = pNexusService->server->mHdmiHotplugEventListenerList[param].begin(); it != pNexusService->server->mHdmiHotplugEventListenerList[param].end(); ++it) {
            LOGV("%s: Firing off HDMI%d hotplug %s event for listener %p...", __PRETTY_FUNCTION__, param,
                 (status.connected && status.rxPowered) ? "connected" : "disconnected", (*it).get());
            (*it)->onHdmiHotplugEventReceived(param, status.connected && status.rxPowered);
        }
    }
#endif
}

int NexusService::platformInitHdmiOutputs()
{
    int rc = 0;
#if NEXUS_HAS_HDMI_OUTPUT
    NEXUS_PlatformConfiguration *pPlatformConfig;

    pPlatformConfig = reinterpret_cast<NEXUS_PlatformConfiguration *>(BKNI_Malloc(sizeof(*pPlatformConfig)));
    if (pPlatformConfig == NULL) {
        ALOGE("%s: Could not allocate enough memory for the platform configuration!!!", __FUNCTION__);
        return NEXUS_OUT_OF_SYSTEM_MEMORY;
    }

    NEXUS_Platform_GetConfiguration(pPlatformConfig);

    for (int index = 0; index < NEXUS_NUM_HDMI_OUTPUTS; index++) {
        NEXUS_HdmiOutputHandle       hdmiOutput;
        NEXUS_HdmiOutputSettings     hdmiSettings;

        hdmiOutput = pPlatformConfig->outputs.hdmi[index];
        NEXUS_HdmiOutput_GetSettings(hdmiOutput, &hdmiSettings);
        hdmiSettings.hotplugCallback.callback = hdmiOutputHotplugCallback;
        hdmiSettings.hotplugCallback.context = this;
        hdmiSettings.hotplugCallback.param = index;
        rc = NEXUS_HdmiOutput_SetSettings(hdmiOutput, &hdmiSettings);
        if (rc) {
            ALOGE("%s: Could not set HDMI%d output settings!!!", __PRETTY_FUNCTION__, index);
        }
#if ANDROID_ENABLE_HDMI_HDCP
        /* initalize HDCP settings, keys, etc. */
        NEXUS_HdmiOutputHdcpSettings hdmiOutputHdcpSettings;

        NEXUS_HdmiOutput_GetHdcpSettings(hdmiOutput, &hdmiOutputHdcpSettings);

        /* copy the encrypted key set and its Aksv here */
        BKNI_Memcpy(hdmiOutputHdcpSettings.encryptedKeySet, encryptedTxKeySet, NEXUS_HDMI_OUTPUT_HDCP_NUM_KEYS * sizeof(NEXUS_HdmiOutputHdcpKey));
        BKNI_Memcpy(&hdmiOutputHdcpSettings.aksv, &hdcpTxAksv, NEXUS_HDMI_OUTPUT_HDCP_KSV_LENGTH);

        /* install HDCP success callback */
        hdmiOutputHdcpSettings.successCallback.callback = hdmiOutputHdcpStateChangedCallback;
        hdmiOutputHdcpSettings.successCallback.context = hdmiOutput;

        /* install HDCP failure callback */
        hdmiOutputHdcpSettings.failureCallback.callback = hdmiOutputHdcpStateChangedCallback;
        hdmiOutputHdcpSettings.failureCallback.context = hdmiOutput;

        NEXUS_HdmiOutput_SetHdcpSettings(hdmiOutput, &hdmiOutputHdcpSettings);

        /* install list of revoked KSVs from SRMs (System Renewability Message) if available */
        NEXUS_HdmiOutput_SetHdcpRevokedKsvs(hdmiOutput, RevokedKsvs, NumRevokedKsvs) ;
        NEXUS_HdmiOutput_StartHdcpAuthentication(hdmiOutput);
#endif
    }
    BKNI_Free(pPlatformConfig);
#endif
    return rc;
}

void NexusService::platformUninitHdmiOutputs()
{
#if NEXUS_HAS_HDMI_OUTPUT
    NEXUS_PlatformConfiguration *pPlatformConfig;

    pPlatformConfig = reinterpret_cast<NEXUS_PlatformConfiguration *>(BKNI_Malloc(sizeof(*pPlatformConfig)));
    if (pPlatformConfig == NULL) {
        ALOGE("%s: Could not allocate enough memory for the platform configuration!!!", __FUNCTION__);
        return;
    }

    NEXUS_Platform_GetConfiguration(pPlatformConfig);

    for (int index = 0; index < NEXUS_NUM_HDMI_OUTPUTS; index++) {
        NEXUS_HdmiOutputHandle      hdmiOutput;
        NEXUS_HdmiOutputSettings    hdmiSettings;

        hdmiOutput = pPlatformConfig->outputs.hdmi[index];

#if ANDROID_ENABLE_HDMI_HDCP
        NEXUS_HdmiOutputHdcpSettings hdmiOutputHdcpSettings;

        NEXUS_HdmiOutput_DisableHdcpAuthentication(hdmiOutput);

        NEXUS_HdmiOutput_GetHdcpSettings(hdmiOutput, &hdmiOutputHdcpSettings);
        hdmiOutputHdcpSettings.successCallback.callback = NULL;
        hdmiOutputHdcpSettings.successCallback.context = NULL;
        hdmiOutputHdcpSettings.failureCallback.callback = NULL;
        hdmiOutputHdcpSettings.failureCallback.context = NULL;
        NEXUS_HdmiOutput_SetHdcpSettings(hdmiOutput, &hdmiOutputHdcpSettings);
#endif
        NEXUS_HdmiOutput_GetSettings(hdmiOutput, &hdmiSettings);
        hdmiSettings.hotplugCallback.callback = NULL;
        hdmiSettings.hotplugCallback.context = NULL;
        hdmiSettings.hotplugCallback.param = 0;
        if (NEXUS_HdmiOutput_SetSettings(hdmiOutput, &hdmiSettings)) {
            ALOGE("%s: Could not set HDMI%d output settings!!!", __PRETTY_FUNCTION__, index);
        }
    }
    BKNI_Free(pPlatformConfig);
#endif
}

int NexusService::platformInitVideo(void)
{
    NEXUS_DisplaySettings          displaySettings;
    NEXUS_PlatformConfiguration   *pPlatformConfig;
    NEXUS_VideoDecoderOpenSettings videoDecoderOpenSettings;
    int rc = 0;
    
    pPlatformConfig = reinterpret_cast<NEXUS_PlatformConfiguration *>(BKNI_Malloc(sizeof(*pPlatformConfig)));
    if (pPlatformConfig == NULL) {
        ALOGE("%s: Could not allocate enough memory for the platform configuration!!!", __FUNCTION__);
        return NEXUS_OUT_OF_SYSTEM_MEMORY;
    }
    NEXUS_Platform_GetConfiguration(pPlatformConfig);
    
    /* Init displays */
    for(int j=0; j<MAX_NUM_DISPLAYS; j++) {
        NEXUS_Display_GetDefaultSettings(&displaySettings);
        displaySettings.displayType = NEXUS_DisplayType_eAuto;
        displaySettings.format = (j == HD_DISPLAY) ? initial_hd_format : initial_sd_format;       
        displayState[j].display = NEXUS_Display_Open(j, &displaySettings);
        if (!displayState[j].display) {
            LOGE("%s: NEXUS_Display_Open(%d) failed!!", __PRETTY_FUNCTION__, j);
            BKNI_Free(pPlatformConfig);
            return NEXUS_UNKNOWN;
        }
        displayState[j].hNexusDisplay = reinterpret_cast<int>(displayState[j].display);
    }
    
#if NEXUS_NUM_COMPONENT_OUTPUTS
    /* Add Component Output to the HD-Display */
    rc = NEXUS_Display_AddOutput(displayState[HD_DISPLAY].display, NEXUS_ComponentOutput_GetConnector(pPlatformConfig->outputs.component[0]));
    if (rc!=NEXUS_SUCCESS) {
        LOGE("%s: NEXUS_Display_AddOutput(component) failed!!", __PRETTY_FUNCTION__);
        BKNI_Free(pPlatformConfig);
        return rc;
    }
#endif

#if NEXUS_HAS_HDMI_OUTPUT && NEXUS_NUM_HDMI_OUTPUTS
    /* Add HDMI Output to the HD-Display */
    rc = NEXUS_Display_AddOutput(displayState[HD_DISPLAY].display, NEXUS_HdmiOutput_GetVideoConnector(pPlatformConfig->outputs.hdmi[0]));
    if (rc!=NEXUS_SUCCESS) {
        LOGE("%s: NEXUS_Display_AddOutput(hdmi) failed!!", __PRETTY_FUNCTION__);
        BKNI_Free(pPlatformConfig);
        return rc;
    }
#endif

    for (int j=0; j<MAX_NUM_DISPLAYS; j++) {
        for (int i=0; i<MAX_VIDEO_WINDOWS_PER_DISPLAY; i++) {
            displayState[j].video_window[i] = NEXUS_VideoWindow_Open(displayState[j].display, i);
            if (!displayState[j].video_window[i]) {
                LOGE("%s: NEXUS_VideoWindow_Open(%d) failed!!", __PRETTY_FUNCTION__, i);
                BKNI_Free(pPlatformConfig);
                return NEXUS_UNKNOWN;
            }
            displayState[j].hNexusVideoWindow[i] = reinterpret_cast<int>(displayState[j].video_window[i]);
        }
    }

    for (int i=0; i<MAX_VIDEO_DECODERS; i++) {
        NEXUS_SimpleVideoDecoderServerSettings settings;

        // open video decoder
        NEXUS_VideoDecoder_GetDefaultOpenSettings(&videoDecoderOpenSettings);
        videoDecoderOpenSettings.fifoSize = VIDEO_DECODER_FIFO_SIZE;
        if (i == 0) {
            videoDecoderOpenSettings.svc3dSupported = true;
        }

        videoDecoder[i] = NEXUS_VideoDecoder_Open(i, &videoDecoderOpenSettings); 
        if (!videoDecoder[i]) {
            LOGE("%s: NEXUS_VideoDecoder_Open(%d) failed!!", __PRETTY_FUNCTION__, i);
            BKNI_Free(pPlatformConfig);
            return NEXUS_UNKNOWN;
        }

        NEXUS_VideoDecoderSettings videoDecoderSettings;
        NEXUS_PlatformSettings     platformSettings;
        NEXUS_Platform_GetSettings(&platformSettings);
        if ((i==0) && (platformSettings.videoDecoderModuleSettings.supportedCodecs[NEXUS_VideoCodec_eH265])) {
            NEXUS_VideoDecoder_GetSettings(videoDecoder[i], &videoDecoderSettings);
            videoDecoderSettings.supportedCodecs[NEXUS_VideoCodec_eH265] = true;
            videoDecoderSettings.maxWidth  = 3840; 
            videoDecoderSettings.maxHeight = 2160;
            NEXUS_VideoDecoder_SetSettings(videoDecoder[i], &videoDecoderSettings);
        }

        // create simple video decoder 
        NEXUS_SimpleVideoDecoder_GetDefaultServerSettings(&settings);
        settings.videoDecoder = videoDecoder[i];
        settings.window[0] = NULL;
        settings.stcIndex = i;  /* Must set this to be able to do STC trick modes! */
        simpleVideoDecoder[i] = NEXUS_SimpleVideoDecoder_Create(i, &settings);
        if (!simpleVideoDecoder[i]) {
            LOGE("%s: NEXUS_SimpleVideoDecoder_Open(%d) failed!!", __PRETTY_FUNCTION__, i);
            BKNI_Free(pPlatformConfig);
            return NEXUS_UNKNOWN;
        }

        //
        // by default give video_window to the simplevideodecoder
        // Note: simplevideodecoder_start will connect videodecoder to the videowindow
        // later if we want to disconnect and connect other videoinput (say, HDMI-input)
        // stop simplevideodecoder, set below to NULL and add new videoinput explicitly 
        // to the video window.
        //
        NEXUS_SimpleVideoDecoder_GetServerSettings(simpleVideoDecoder[i], &settings);
        for (int j=0; j<MAX_NUM_DISPLAYS; j++) {
            settings.window[j] = displayState[j].video_window[i >= MAX_VIDEO_WINDOWS_PER_DISPLAY ? MAX_VIDEO_WINDOWS_PER_DISPLAY-1 : i];
        }
        NEXUS_SimpleVideoDecoder_SetServerSettings(simpleVideoDecoder[i], &settings);
    }
    BKNI_Free(pPlatformConfig);
    return rc;
}

void NexusService::setVideoState(bool enable)
{
    for(int i=0; i<MAX_VIDEO_DECODERS; i++)
    {
        NEXUS_SimpleVideoDecoderServerSettings settings;

        NEXUS_SimpleVideoDecoder_GetServerSettings(simpleVideoDecoder[i], &settings);
        settings.enabled = enable;
        NEXUS_SimpleVideoDecoder_SetServerSettings(simpleVideoDecoder[i], &settings);
    }
    return;
}

void framebuffer_callback(void *context, int param)
{
    BSTD_UNUSED(context);
    BSTD_UNUSED(param);
}

static BKNI_EventHandle inactiveEvent;
static void inactive_callback(void *context, int param)
{    
    BSTD_UNUSED(param);    
    BKNI_SetEvent((BKNI_EventHandle)context);
}

/* Event callback that will be called when a gfx op is complete */
static void complete(void *data, int unused)
{
    BSTD_UNUSED(unused);
    BKNI_SetEvent((BKNI_EventHandle)data);
}

int NexusService::platformInitSurfaceCompositor(void)
{
    NEXUS_SurfaceCreateSettings createSettings;
    int rc=0; unsigned i;
    NEXUS_SurfaceCompositorSettings *p_surface_compositor_settings = NULL;
    NEXUS_VideoFormatInfo formatInfo;
    NEXUS_VideoFormat_GetInfo(initial_hd_format, &formatInfo);

    BKNI_CreateEvent(&inactiveEvent);
    p_surface_compositor_settings = (NEXUS_SurfaceCompositorSettings *)BKNI_Malloc(sizeof(NEXUS_SurfaceCompositorSettings));
    if (NULL == p_surface_compositor_settings) {
        LOGE("%s:%d BKNI_Malloc failed",__PRETTY_FUNCTION__,__LINE__);
        return NEXUS_OUT_OF_SYSTEM_MEMORY;
    }

    /* create surface compositor server */
    surface_compositor = NEXUS_SurfaceCompositor_Create(0);
    if (surface_compositor == NULL) {
        LOGE("%s: Could not create Surface Compositor 0!!!", __PRETTY_FUNCTION__);
        BKNI_Free(p_surface_compositor_settings);
        return NEXUS_UNKNOWN;
    }
    NEXUS_SurfaceCompositor_GetSettings(surface_compositor, p_surface_compositor_settings);
    NEXUS_Display_GetGraphicsSettings(displayState[HD_DISPLAY].display, &p_surface_compositor_settings->display[HD_DISPLAY].graphicsSettings);
    // Give space for videowindows to change zorder without using same one twice
    p_surface_compositor_settings->display[HD_DISPLAY].graphicsSettings.zorder = MAX_VIDEO_WINDOWS_PER_DISPLAY + 1;
    p_surface_compositor_settings->display[HD_DISPLAY].graphicsSettings.enabled = true;
    p_surface_compositor_settings->display[HD_DISPLAY].display = displayState[HD_DISPLAY].display;
    p_surface_compositor_settings->display[HD_DISPLAY].framebuffer.number = 2;
    p_surface_compositor_settings->display[HD_DISPLAY].framebuffer.width = formatInfo.width;
    p_surface_compositor_settings->display[HD_DISPLAY].framebuffer.height = formatInfo.height;
    p_surface_compositor_settings->display[HD_DISPLAY].framebuffer.backgroundColor = 0; /* black background */
    p_surface_compositor_settings->display[HD_DISPLAY].framebuffer.heap = NEXUS_Platform_GetFramebufferHeap(0);

    if((NEXUS_VideoFormat_e720p_3DOU_AS == initial_hd_format) || (NEXUS_VideoFormat_e1080p24hz_3DOU_AS == initial_hd_format)) {
        p_surface_compositor_settings->display[HD_DISPLAY].display3DSettings.overrideOrientation = true;
        p_surface_compositor_settings->display[HD_DISPLAY].display3DSettings.orientation = NEXUS_VideoOrientation_e2D;
    }
    p_surface_compositor_settings->frameBufferCallback.callback = framebuffer_callback;
    p_surface_compositor_settings->frameBufferCallback.context = surface_compositor;
    p_surface_compositor_settings->inactiveCallback.callback = inactive_callback;
    p_surface_compositor_settings->inactiveCallback.context = inactiveEvent;
    rc = NEXUS_SurfaceCompositor_SetSettings(surface_compositor, p_surface_compositor_settings);
    if (rc) {
        LOGE("%s:%d NSC_SetSettings failed",__PRETTY_FUNCTION__,__LINE__);
    }
    BKNI_Free(p_surface_compositor_settings);
    return rc;
}

/* This function reads persist.hd_output_format and persist.sd_output_format properties and
   return respective enums for hd and sd formats. These HD and SD output formats
   are the initial configuration with which Android boots up. */
void NexusService::getInitialOutputFormats(
        NEXUS_VideoFormat *hd_format, NEXUS_VideoFormat *sd_format)
{
    char value[PROPERTY_VALUE_MAX];
    NEXUS_VideoFormat fmt;

    // HD output format
    if(property_get("persist.hd_output_format", value, NULL))
    {
        fmt = (NEXUS_VideoFormat)lookup(g_videoFormatStrs, value);
        ALOGW("Set output format to %s", lookup_name(g_videoFormatStrs, fmt));
    }
    else
    {
        ALOGW("Set output format to default e720p");
        fmt = NEXUS_VideoFormat_e720p;
    }

    if(hd_format) *hd_format = fmt;

    // SD output format
    if(property_get("persist.sd_output_format", value, NULL))
    {
        if (strncmp((char *) value, "PAL",3)==0)
        {
            ALOGW("Set SD output format to PAL...");
            fmt = NEXUS_VideoFormat_ePal;
        }
        else
        {
            ALOGW("Set SD output format to NTSC");
            fmt = NEXUS_VideoFormat_eNtsc;
        }
    }
    else
    {
        ALOGW("Set SD output format to default Ntsc");
        fmt = NEXUS_VideoFormat_eNtsc;
    }
    if(sd_format) *sd_format = fmt;

    return;
}

void NexusService::platformInit()
{
    NEXUS_Error                        rc;
    int                                i=0;
    char                               value[PROPERTY_VALUE_MAX];
    NEXUS_Graphics2DSettings           gfxSettings;
    NEXUS_PlatformStartServerSettings  serverSettings;

    NEXUS_Platform_GetDefaultStartServerSettings(&serverSettings);

    serverSettings.allowUnprotectedClientsToCrash = true;
    serverSettings.allowUnauthenticatedClients = false;

    rc = NEXUS_Platform_StartServer(&serverSettings);
    if (rc != NEXUS_SUCCESS) {
        LOGE("%s:NEXUS_Platform_StartServer Failed (rc=%d)!\n", __PRETTY_FUNCTION__, rc);
        BDBG_ASSERT(rc == NEXUS_SUCCESS);
    }

    for (i=0; i<MAX_NUM_DISPLAYS; i++) {
        BKNI_Memset(&displayState[i], 0, sizeof(DisplayState));
    }

    for (i=0; i<MAX_AUDIO_DECODERS; i++) {
        audioDecoder[i] = NULL;
        simpleAudioDecoder[i] = NULL;
    }

    for (i=0; i<MAX_AUDIO_PLAYBACKS; i++) {
        audioPlayback[i] = NULL;
        simpleAudioPlayback[i] = NULL;
    }

    for (i=0; i<MAX_VIDEO_DECODERS; i++) {
        videoDecoder[i] = NULL;
        simpleVideoDecoder[i] = NULL;
    }

    for (i=0; i<MAX_ENCODERS; i++) {
        simpleEncoder[i] = NULL;
    }

    getInitialOutputFormats(&initial_hd_format, &initial_sd_format);

    gfx2D = NEXUS_Graphics2D_Open(NEXUS_ANY_ID,NULL);

    BKNI_CreateEvent(&gfxDone);
    NEXUS_Graphics2D_GetSettings(gfx2D, &gfxSettings);
    gfxSettings.checkpointCallback.callback = complete;
    gfxSettings.checkpointCallback.context = gfxDone;
    NEXUS_Graphics2D_SetSettings(gfx2D, &gfxSettings);
    if (platformInitAudio() != 0) {
        LOGE("%s: Could not initialise platform audio!!!", __PRETTY_FUNCTION__);
        BDBG_ASSERT(false);
    }
    else {
        if (platformInitVideo() != 0) {
            LOGE("%s: Could not initialise platform video!!!", __PRETTY_FUNCTION__);
            BDBG_ASSERT(false);
        }
        else {
            if (platformInitHdmiOutputs() != 0) {
                LOGE("%s: Could not initialise HDMI output(s)!!!", __PRETTY_FUNCTION__);
                BDBG_ASSERT(false);
            }
            else {
                if (platformInitSurfaceCompositor() != 0) {
                    LOGE("%s: Could not initialise surface compositor!!!", __PRETTY_FUNCTION__);
                    BDBG_ASSERT(false);
                }
            }
        }
    }

#if NEXUS_HAS_CEC
    i = NEXUS_NUM_CEC;
    while (i--) {
        if (isCecEnabled(i)) {
            mCecServiceManager[i] = CecServiceManager::instantiate(this, i);

            if (mCecServiceManager[i] != NULL) {
                if (mCecServiceManager[i]->platformInit() != OK) {
                    LOGE("%s: ERROR initialising CecServiceManager platform for CEC%d!", __PRETTY_FUNCTION__, i);
                    mCecServiceManager[i] = NULL;
                }
            }
            else {
                LOGE("%s: ERROR instantiating CecServiceManager for CEC%d!", __PRETTY_FUNCTION__, i);
            }
        }
    }
#endif
}

void NexusService::platformUninit()
{
    platformUninitHdmiOutputs();

#if NEXUS_HAS_CEC
    for (unsigned i = 0; i < NEXUS_NUM_CEC; i++) {
        if (mCecServiceManager[i] != NULL) {
            mCecServiceManager[i]->platformUninit();
            mCecServiceManager[i] = NULL;
        }
    }
#endif

    if (gfx2D) {
        NEXUS_Graphics2D_Close(gfx2D);
        gfx2D = NULL;
    }
}

void NexusService::instantiate() {
    NexusServerContext *server = new NexusServerContext();

    if (server == NULL) {
        LOGE("%s: FATAL: Could not allocate memory for NexusServerContext!", __PRETTY_FUNCTION__);
        BDBG_ASSERT(server != NULL);
    }

    NexusService *nexusservice = new NexusService();

    if (nexusservice != NULL) {
        nexusservice->platformInit();
        nexusservice->server = server;

        defaultServiceManager()->addService(
                    INexusService::descriptor, nexusservice);
    }
    else {
        LOGE("%s: Could not instantiate NexusService!!!", __PRETTY_FUNCTION__);
    }
}

NexusService::NexusService() : powerState(ePowerState_S0)
{
    LOGI("NexusService Created");
    surface_compositor = NULL;
    surfaceclient = NULL;
    gfx2D = NULL;
}

NexusService::~NexusService()
{
    LOGI("NexusService Destroyed");

    platformUninit();

    delete server;
    server = NULL;
}

NEXUS_ClientHandle NexusService::clientJoin(const b_refsw_client_client_name *pClientName, NEXUS_ClientAuthenticationSettings *pClientAuthenticationSettings)
{
    NEXUS_ClientHandle nexusClient;

    Mutex::Autolock autoLock(server->mLock);

    nexusClient = NULL;

    pClientAuthenticationSettings->certificate.length =
        BKNI_Snprintf((char *)pClientAuthenticationSettings->certificate.data,
                      sizeof(pClientAuthenticationSettings->certificate.data),
                      "%u,%#x%#x,%s", server->lastId.client, lrand48(), lrand48(), pClientName->string);

    if (pClientAuthenticationSettings->certificate.length >= sizeof(pClientAuthenticationSettings->certificate.data)-1) {
        LOGE("%s: Invalid certificate length %d for client \"%s\"!!!", __PRETTY_FUNCTION__, pClientAuthenticationSettings->certificate.length, pClientName->string);
        (void)BERR_TRACE(BERR_NOT_SUPPORTED);
    }
    else {
        NEXUS_PlatformConfiguration *pPlatformConfig;
        NEXUS_ClientSettings         clientSettings;

        pPlatformConfig = reinterpret_cast<NEXUS_PlatformConfiguration *>(BKNI_Malloc(sizeof(*pPlatformConfig)));
        if (pPlatformConfig == NULL) {
            ALOGE("%s: Could not allocate enough memory for the platform configuration!!!", __FUNCTION__);
            (void)BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
        }
        else {
            LOGI("client %s registering as '%s'", pClientName->string, (char *)pClientAuthenticationSettings->certificate.data);

            NEXUS_Platform_GetDefaultClientSettings(&clientSettings);
            clientSettings.authentication.certificate = pClientAuthenticationSettings->certificate;
            NEXUS_Platform_GetConfiguration(pPlatformConfig);
            clientSettings.configuration.heap[0] = NEXUS_Platform_GetFramebufferHeap(NEXUS_OFFSCREEN_SURFACE);
            clientSettings.configuration.heap[1] = pPlatformConfig->heap[NEXUS_MAIN_HEAP_IDX];
#ifdef NEXUS_VIDEO_SECURE_HEAP
            clientSettings.configuration.heap[2] = pPlatformConfig->heap[NEXUS_VIDEO_SECURE_HEAP];
#endif
#ifdef NEXUS_SECONDARY_OFFSCREEN_SURFACE
            clientSettings.configuration.heap[3] = NEXUS_Platform_GetFramebufferHeap(NEXUS_SECONDARY_OFFSCREEN_SURFACE);
            if (clientSettings.configuration.heap[3] == clientSettings.configuration.heap[0]) {
                clientSettings.configuration.heap[3] = NULL;
            }
#endif
            nexusClient = NEXUS_Platform_RegisterClient(&clientSettings);
            if (nexusClient) {
                LOGI("%s: Successfully registered client \"%s\".", __PRETTY_FUNCTION__, pClientName->string);
                server->lastId.client++;
                server->mJoinRefCount++;
            }
            else {
                LOGE("%s: Could not register client \"%s\"!!!", __PRETTY_FUNCTION__, pClientName->string);
                (void)BERR_TRACE(BERR_NOT_SUPPORTED);
            }
            BKNI_Free(pPlatformConfig);
        }
    }
    return nexusClient;
}

NEXUS_Error NexusService::clientUninit(NEXUS_ClientHandle nexusClient)
{
    NEXUS_Error rc;

    Mutex::Autolock autoLock(server->mLock);

    server->mJoinRefCount--;

    if (nexusClient == NULL) {
        LOGE("%s: Nexus client handle is NULL!!!", __PRETTY_FUNCTION__);
        rc = NEXUS_INVALID_PARAMETER;
    }
    else {
        NEXUS_Platform_UnregisterClient(nexusClient);
        rc = NEXUS_SUCCESS;
    }
    return rc;
}

NexusClientContext * NexusService::createClientContext(const b_refsw_client_client_configuration *config)
{
    NexusClientContext * client;
    NEXUS_ClientSettings clientSettings;
    NEXUS_Error rc;

    Mutex::Autolock autoLock(server->mLock);

    client = (NexusClientContext *)BKNI_Malloc(sizeof(NexusClientContext));
    if (client==NULL) {
        (void)BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
        return NULL;
    }

    BKNI_Memset(client, 0, sizeof(*client));
    BDBG_OBJECT_SET(client, NexusClientContext);

    client->createConfig = *config;

    BLST_D_INSERT_HEAD(&server->clients, client, link);

    client->ipc.nexusClient = getNexusClient(client->createConfig.pid,
        client->createConfig.name.string);

    if (powerState != ePowerState_S0) {
        NEXUS_PlatformStandbySettings nexusStandbySettings;

        LOGI("We need to set Nexus Power State S0 first...");
        NEXUS_Platform_GetStandbySettings(&nexusStandbySettings);
        nexusStandbySettings.mode = NEXUS_PlatformStandbyMode_eOn;    
        rc = NEXUS_Platform_SetStandbySettings(&nexusStandbySettings);
        if (rc != NEXUS_SUCCESS) {
            LOGE("Oops we couldn't set Nexus Power State to S0!");
            goto err_client;
        }
        else {
            LOGI("Successfully set Nexus Power State S0");
        }
    }
    LOGI("%s: Exiting with client=%p", __PRETTY_FUNCTION__, (void *)client);
    return client;

err_client:
    /* todo fix cleanup */
    return NULL;
}

void NexusService::destroyClientContext(NexusClientContext * client)
{
    Mutex::Autolock autoLock(server->mLock);

    BDBG_OBJECT_ASSERT(client, NexusClientContext);
    if(client->ipc.nexusClient) {
        client->ipc.nexusClient = NULL;
    }
    BLST_D_REMOVE(&server->clients, client, link);
    BDBG_OBJECT_DESTROY(client, NexusClientContext);
    BKNI_Free(client);
}

bool NexusService::setCecEnabled(uint32_t cecId __unused, bool enabled)
{
    bool success = true;
    char value[PROPERTY_VALUE_MAX];

    snprintf(value, PROPERTY_VALUE_MAX, "%d", enabled);

    if (property_set(PROPERTY_HDMI_ENABLE_CEC, value) != 0) {
        success = false;
    }
    return success;
}

bool NexusService::isCecEnabled(uint32_t cecId __unused)
{
    bool enabled = false;
#if NEXUS_HAS_CEC
    char value[PROPERTY_VALUE_MAX];

    if (property_get(PROPERTY_HDMI_ENABLE_CEC, value, DEFAULT_PROPERTY_HDMI_ENABLE_CEC) && (strcmp(value,"1")==0 || strcmp(value, "true")==0)) {
        enabled = true;
    }
#endif
    return enabled;
}

bool NexusService::setCecAutoWakeupEnabled(uint32_t cecId __unused, bool enabled)
{
    bool success = true;
    char value[PROPERTY_VALUE_MAX];

    snprintf(value, PROPERTY_VALUE_MAX, "%d", enabled);

    if (property_set(PROPERTY_HDMI_AUTO_WAKEUP_CEC, value) != 0) {
        success = false;
    }
    return success;
}

bool NexusService::isCecAutoWakeupEnabled(uint32_t cecId __unused)
{
    bool enabled = false;
    char value[PROPERTY_VALUE_MAX];

    if (property_get(PROPERTY_HDMI_AUTO_WAKEUP_CEC, value, DEFAULT_PROPERTY_HDMI_AUTO_WAKEUP_CEC) && (strcmp(value,"1")==0 || strcmp(value, "true")==0)) {
        enabled = true;
    }
    return enabled;
}

bool NexusService::setCecLogicalAddress(unsigned cecId, uint8_t addr)
{
    bool success = false;
#if NEXUS_HAS_CEC
    if (mCecServiceManager[cecId] != NULL && mCecServiceManager[cecId]->isPlatformInitialised()) {
        success = mCecServiceManager[cecId]->setLogicalAddress(addr);
    }
#endif
    if (!success) {
        LOGE("%s: Could not set CEC%d logical address to 0x%02x!", __PRETTY_FUNCTION__, cecId, addr);
    }
    return success;
}

bool NexusService::setCecPowerState(unsigned cecId, b_powerState pmState)
{
    bool success = false;
#if NEXUS_HAS_CEC
    if (mCecServiceManager[cecId] != NULL && mCecServiceManager[cecId]->isPlatformInitialised()) {
        success = mCecServiceManager[cecId]->setPowerState(pmState);
    }
#endif
    if (!success) {
        LOGE("%s: Could not set CEC%d power state %d!", __PRETTY_FUNCTION__, cecId, pmState);
    }
    return success;
}

bool NexusService::getCecPowerStatus(uint32_t cecId, uint8_t *pPowerStatus)
{
    bool success = false;
#if NEXUS_HAS_CEC
    if (mCecServiceManager[cecId] != NULL && mCecServiceManager[cecId]->isPlatformInitialised()) {
        success = mCecServiceManager[cecId]->getPowerStatus(pPowerStatus);
    }
#endif
    if (!success) {
        LOGE("%s: Could not get CEC%d TV power status!", __PRETTY_FUNCTION__, cecId);
    }
    return success;
}

bool NexusService::getCecStatus(uint32_t cecId, b_cecStatus *pCecStatus)
{
    bool success = false;
#if NEXUS_HAS_CEC
    if (mCecServiceManager[cecId] != NULL && mCecServiceManager[cecId]->isPlatformInitialised()) {
        success = mCecServiceManager[cecId]->getCecStatus(pCecStatus);
    }
#endif
    if (!success) {
        LOGE("%s: Could not get CEC%d TV status!", __PRETTY_FUNCTION__, cecId);
    }
    return success;
}

bool NexusService::getHdmiOutputStatus(uint32_t portId, b_hdmiOutputStatus *pHdmiOutputStatus)
{
    NEXUS_Error rc = NEXUS_NOT_SUPPORTED;
#if NEXUS_HAS_HDMI_OUTPUT
    if (portId < NEXUS_NUM_HDMI_OUTPUTS) {
        unsigned loops;
        NEXUS_HdmiOutputHandle hdmiOutput;
        NEXUS_PlatformConfiguration *pPlatformConfig;
        NEXUS_HdmiOutputStatus status;

        memset(pHdmiOutputStatus, 0, sizeof(*pHdmiOutputStatus));

        pPlatformConfig = reinterpret_cast<NEXUS_PlatformConfiguration *>(BKNI_Malloc(sizeof(*pPlatformConfig)));
        if (pPlatformConfig == NULL) {
            ALOGE("%s: Could not allocate enough memory for the platform configuration!!!", __FUNCTION__);
            return false;
        }
        NEXUS_Platform_GetConfiguration(pPlatformConfig);
        hdmiOutput = pPlatformConfig->outputs.hdmi[portId];
        BKNI_Free(pPlatformConfig);

        if (hdmiOutput != NULL) {
            for (loops = 0; loops < 4; loops++) {
                rc = NEXUS_HdmiOutput_GetStatus(hdmiOutput, &status);
                if ((rc == NEXUS_SUCCESS) && status.connected) {
                    break;
                }
                LOGV("%s: Waiting for HDMI%d output to be connected...", __PRETTY_FUNCTION__, portId);
                usleep(250 * 1000);
            }
        }
        
        if (rc == NEXUS_SUCCESS) {
            if (status.connected) {
                pHdmiOutputStatus->connected            = status.connected;
                pHdmiOutputStatus->rxPowered            = status.rxPowered;
                pHdmiOutputStatus->hdmiDevice           = status.hdmiDevice;
                pHdmiOutputStatus->videoFormat          = status.videoFormat;
                pHdmiOutputStatus->preferredVideoFormat = status.preferredVideoFormat;
                pHdmiOutputStatus->aspectRatio          = status.aspectRatio;
                pHdmiOutputStatus->colorSpace           = status.colorSpace;
                pHdmiOutputStatus->audioFormat          = status.audioFormat;
                pHdmiOutputStatus->audioSamplingRate    = status.audioSamplingRate;
                pHdmiOutputStatus->audioSamplingSize    = status.audioSamplingSize;
                pHdmiOutputStatus->audioChannelCount    = status.audioChannelCount;
                pHdmiOutputStatus->physicalAddress[0]   = status.physicalAddressA << 4 | status.physicalAddressB;
                pHdmiOutputStatus->physicalAddress[1]   = status.physicalAddressC << 4 | status.physicalAddressD;
            }
        }
        else {
            LOGE("%s: Could not get HDMI%d output status!!!", __PRETTY_FUNCTION__, portId);
        }
    }
    else
#endif
    {
        LOGE("%s: No HDMI%d output on this device!!!", __PRETTY_FUNCTION__, portId);
    }
    return (rc == NEXUS_SUCCESS);
}

bool NexusService::sendCecMessage(unsigned cecId, uint8_t srcAddr, uint8_t destAddr, size_t length, uint8_t *pMessage)
{
    bool success = false;
#if NEXUS_HAS_CEC
    if (mCecServiceManager[cecId] != NULL && mCecServiceManager[cecId]->isPlatformInitialised()) {
        success = (mCecServiceManager[cecId]->sendCecMessage(srcAddr, destAddr, length, pMessage) == OK) ? true : false;
    }
#endif
    if (!success) {
        LOGE("%s: Could not send CEC%d message opcode: 0x%02X!", __PRETTY_FUNCTION__, cecId, *pMessage);
    }
    return success;
}

void NexusService::setDisplayState(bool enable)
{
    NEXUS_SurfaceCompositorSettings *p_surface_compositor_settings = NULL;
    int rc;

    p_surface_compositor_settings = (NEXUS_SurfaceCompositorSettings *)BKNI_Malloc(sizeof(NEXUS_SurfaceCompositorSettings));
    if (NULL == p_surface_compositor_settings) {
        while(1) LOGE("%s:%d BKNI_Malloc failed",__PRETTY_FUNCTION__,__LINE__);
        return;
    }

    NEXUS_SurfaceCompositor_GetSettings(surface_compositor, p_surface_compositor_settings);

    if (!enable) {
        BKNI_ResetEvent(inactiveEvent);

        /* disable surface compositor */
        p_surface_compositor_settings->enabled = false;
        NEXUS_SurfaceCompositor_SetSettings(surface_compositor, p_surface_compositor_settings);
        rc = BKNI_WaitForEvent(inactiveEvent, 5000);
        if (rc) {
            LOGE("Did not receive NSC inactive event!");
            if(p_surface_compositor_settings)
                BKNI_Free(p_surface_compositor_settings);
            return;
        }
    }
    else {
        p_surface_compositor_settings->enabled = true;
        NEXUS_SurfaceCompositor_SetSettings(surface_compositor, p_surface_compositor_settings);
    }

    if (p_surface_compositor_settings) {
        BKNI_Free(p_surface_compositor_settings);
    }
    return;
}

bool NexusService::setPowerState(b_powerState pmState)
{
    NEXUS_Error rc = NEXUS_SUCCESS;
    NEXUS_PlatformStandbySettings nexusStandbySettings;

    if (pmState != powerState) {
        NEXUS_Platform_GetStandbySettings(&nexusStandbySettings);
        nexusStandbySettings.wakeupSettings.ir = 1;
        nexusStandbySettings.wakeupSettings.uhf = 1;
        nexusStandbySettings.wakeupSettings.transport = 1;
        nexusStandbySettings.wakeupSettings.cec = isCecEnabled(0) && isCecAutoWakeupEnabled(0);
        nexusStandbySettings.wakeupSettings.gpio = 1;
        nexusStandbySettings.wakeupSettings.timeout = 0;

        switch (pmState)
        {
            case ePowerState_S0:
            {
                LOGD("%s: About to set power state S0...", __PRETTY_FUNCTION__);
                nexusStandbySettings.mode = NEXUS_PlatformStandbyMode_eOn;    
                rc = NEXUS_Platform_SetStandbySettings(&nexusStandbySettings);
                if (rc == NEXUS_SUCCESS) {
                    setDisplayState(1);
                    setVideoState(1);
                    setAudioState(1);
                }
                break;
            }

            case ePowerState_S1:
            {
                LOGD("%s: About to set power state S1...", __PRETTY_FUNCTION__);
                setDisplayState(0);
                setVideoState(0);
                setAudioState(0);
                nexusStandbySettings.mode = NEXUS_PlatformStandbyMode_eActive;    
                rc = NEXUS_Platform_SetStandbySettings(&nexusStandbySettings);
                break;
            }

            case ePowerState_S2:
            {
                LOGD("%s: About to set power state S2...", __PRETTY_FUNCTION__);
                setDisplayState(0);
                setVideoState(0);
                setAudioState(0);
                nexusStandbySettings.mode = NEXUS_PlatformStandbyMode_ePassive;
                rc = NEXUS_Platform_SetStandbySettings(&nexusStandbySettings);
                break;
            }

            case ePowerState_S3:
            case ePowerState_S5:
            {
                LOGD("%s: About to set power state S%d...", __PRETTY_FUNCTION__, pmState-ePowerState_S0);
                setDisplayState(0);
                setVideoState(0);
                setAudioState(0);
                nexusStandbySettings.mode = NEXUS_PlatformStandbyMode_eDeepSleep;  
                rc = NEXUS_Platform_SetStandbySettings(&nexusStandbySettings);
                break;
            }

            default:
            {
                LOGE("%s: invalid power state %d!", __PRETTY_FUNCTION__, pmState);
                rc = NEXUS_INVALID_PARAMETER;
                break;
            }
        }
    }

    if (rc == NEXUS_SUCCESS) {
        powerState = pmState;
        return true;
    } else {
        LOGE("%s: ERROR setting power state to S%d!", __PRETTY_FUNCTION__, pmState);
        return false;
    }
}

b_powerState NexusService::getPowerState()
{
    return powerState;
}

status_t NexusService::setHdmiCecMessageEventListener(uint32_t cecId, const sp<INexusHdmiCecMessageEventListener> &listener)
{
    status_t status = INVALID_OPERATION;
    ALOGV("%s: CEC%d listener=%p", __PRETTY_FUNCTION__, cecId, listener.get());

#if NEXUS_HAS_CEC
    if (cecId < NEXUS_NUM_CEC) {
        if (mCecServiceManager[cecId] != NULL) {
            status = mCecServiceManager[cecId]->setEventListener(listener);
        }

        if (status != OK) {
            LOGE("%s: Could not set CEC%d message listener!", __PRETTY_FUNCTION__, cecId);
        }
    }
    else
#endif
    {
        LOGE("%s: No CEC%d output on this device!!!", __PRETTY_FUNCTION__, cecId);
    }
    return status;
}

status_t NexusService::addHdmiHotplugEventListener(uint32_t portId, const sp<INexusHdmiHotplugEventListener> &listener)
{
    status_t status = OK;

    if (listener == 0) {
        ALOGE("%s: HDMI%d listener is NULL!!!", __PRETTY_FUNCTION__, portId);
        status = BAD_VALUE;
    }
    else {
        ALOGV("%s: HDMI%d listener %p", __PRETTY_FUNCTION__, portId, listener.get());

#if NEXUS_HAS_HDMI_OUTPUT
        if (portId < NEXUS_NUM_HDMI_OUTPUTS) {
            Vector<sp<INexusHdmiHotplugEventListener> >::iterator it;
            sp<IBinder> binder = listener->asBinder();

            Mutex::Autolock autoLock(server->mLock);

            for (it = server->mHdmiHotplugEventListenerList[portId].begin(); it != server->mHdmiHotplugEventListenerList[portId].end(); ++it) {
                if ((*it)->asBinder() == binder) {
                    ALOGE("%s: Already added HDMI%d listener %p!!!", __PRETTY_FUNCTION__, portId, listener.get());
                    status = ALREADY_EXISTS;
                    break;
                }
            }

            if (status == OK) {
                server->mHdmiHotplugEventListenerList[portId].push_back(listener);
                binder->linkToDeath(this);
            }
        }
        else
#endif
        {
            LOGE("%s: No HDMI%d output on this device!!!", __PRETTY_FUNCTION__, portId);
            status = INVALID_OPERATION;
        }
    }
    return status;
}

status_t NexusService::removeHdmiHotplugEventListener(uint32_t portId, const sp<INexusHdmiHotplugEventListener>& listener)
{
    status_t status = BAD_VALUE;

    if (listener == 0) {
        ALOGE("%s: HDMI%d listener is NULL!!!", __PRETTY_FUNCTION__, portId);
    }
    else {
        ALOGV("%s: HDMI%d listener %p", __PRETTY_FUNCTION__, portId, listener.get());

#if NEXUS_HAS_HDMI_OUTPUT
        if (portId < NEXUS_NUM_HDMI_OUTPUTS) {
            Vector<sp<INexusHdmiHotplugEventListener> >::iterator it;
            sp<IBinder> binder = listener->asBinder();

            Mutex::Autolock autoLock(server->mLock);

            for (it = server->mHdmiHotplugEventListenerList[portId].begin(); it != server->mHdmiHotplugEventListenerList[portId].end(); ++it) {
                if ((*it)->asBinder() == binder) {
                    binder->unlinkToDeath(this);
                    server->mHdmiHotplugEventListenerList[portId].erase(it);
                    status = OK;
                    break;
                }
            }

            if (status == BAD_VALUE) {
                ALOGW("%s: Could NOT find HDMI%d listener %p!!!", __PRETTY_FUNCTION__, portId, listener.get());
            }
        }
        else
#endif
        {
            LOGE("%s: No HDMI%d output on this device!!!", __PRETTY_FUNCTION__, portId);
            status = INVALID_OPERATION;
        }
    }
    return status;
}

void NexusService::binderDied(const wp<IBinder>& who)
{
#if NEXUS_HAS_HDMI_OUTPUT
    IBinder *binder = who.unsafe_get();
    if (binder != NULL) {
        Vector<sp<INexusHdmiHotplugEventListener> >::iterator it;

        Mutex::Autolock autoLock(server->mLock);

        for (unsigned portId = 0; portId < NEXUS_NUM_HDMI_OUTPUTS; portId++) {
            for (it = server->mHdmiHotplugEventListenerList[portId].begin(); it != server->mHdmiHotplugEventListenerList[portId].end(); ++it) {
                if ((*it)->asBinder() == binder) {
                    ALOGD("%s: Removing HDMI%d hotplug event listener...", __PRETTY_FUNCTION__, portId);
                    server->mHdmiHotplugEventListenerList[portId].erase(it);
                    return;
                }
            }
        }
    }
#endif
}

#undef CHECK_INTERFACE
#define CHECK_INTERFACE(interface, data, reply) \
        do { if (!data.enforceInterface(interface::getInterfaceDescriptor())) { \
            LOGE("Call incorrectly routed to " #interface); \
            return PERMISSION_DENIED;              \
        } } while (0)

status_t NexusService::onTransact(uint32_t code,
                                  const Parcel &data,
                                  Parcel *reply,
                                  uint32_t flags)
{
    CHECK_INTERFACE(INexusService, data, reply);
    
    switch(code) {
    case API_OVER_BINDER: { /* braces are necessary when declaring variables within case: */
        int rc = 0;
        api_data cmd;
        data.read(&cmd, sizeof(cmd));

        switch(cmd.api)
        {
            case api_clientJoin:
            {
                cmd.param.clientJoin.out.clientHandle = 
                    clientJoin(&cmd.param.clientJoin.in.clientName, &cmd.param.clientJoin.in.clientAuthenticationSettings);
                break;
            }
            case api_clientUninit:
            {
                cmd.param.clientUninit.out.status = clientUninit(cmd.param.clientUninit.in.clientHandle);
                break;
            }
            case api_createClientContext:
            {
                cmd.param.createClientContext.out.client = createClientContext(&cmd.param.createClientContext.in.createClientConfig);
                break;
            }
            case api_destroyClientContext:
            {
                destroyClientContext(cmd.param.destroyClientContext.in.client);
                break;
            }
            case api_setPowerState:
            {
                cmd.param.setPowerState.out.status = setPowerState(cmd.param.setPowerState.in.pmState);
                break;
            }
            case api_getPowerState:
            {
                cmd.param.getPowerState.out.pmState = getPowerState();
                break;
            }
            case api_setCecPowerState:
            {
                cmd.param.setCecPowerState.out.status = setCecPowerState(cmd.param.setCecPowerState.in.cecId,
                                                                         cmd.param.setCecPowerState.in.pmState);
                break;
            }
            case api_getCecPowerStatus:
            {
                cmd.param.getCecPowerStatus.out.status = getCecPowerStatus(cmd.param.getCecPowerStatus.in.cecId,
                                                                          &cmd.param.getCecPowerStatus.out.powerStatus);
                break;
            }
            case api_getCecStatus:
            {
                cmd.param.getCecStatus.out.status = getCecStatus(cmd.param.getCecStatus.in.cecId,
                                                                &cmd.param.getCecStatus.out.cecStatus);
                break;
            }
            case api_sendCecMessage:
            {
                cmd.param.sendCecMessage.out.status = sendCecMessage(cmd.param.sendCecMessage.in.cecId,
                                                                     cmd.param.sendCecMessage.in.srcAddr,
                                                                     cmd.param.sendCecMessage.in.destAddr,
                                                                     cmd.param.sendCecMessage.in.length,
                                                                     cmd.param.sendCecMessage.in.message);
                break;
            }
            case api_setCecLogicalAddress:
            {
                cmd.param.setCecLogicalAddress.out.status = setCecLogicalAddress(cmd.param.setCecLogicalAddress.in.cecId,
                                                                                 cmd.param.setCecLogicalAddress.in.addr);
                break;
            }
            case api_getHdmiOutputStatus:
            {
                cmd.param.getHdmiOutputStatus.out.status = getHdmiOutputStatus(cmd.param.getHdmiOutputStatus.in.portId,
                                                                              &cmd.param.getHdmiOutputStatus.out.hdmiOutputStatus);
                break;
            }
            default:
            {
                LOGE("%s: Unhandled cmd = %d",__PRETTY_FUNCTION__,cmd.api);
                return INVALID_OPERATION;
            }
        } /* switch(cmd.api) */

        if(!rc)
        {
            reply->write(&cmd.param, sizeof(cmd.param));
            return NO_ERROR;
        }
        else
        {
            return FAILED_TRANSACTION;
        }
    } break; 

    case SET_HDMI_CEC_MESSAGE_EVENT_LISTENER: {
        uint32_t cecId = data.readInt32();
        sp<INexusHdmiCecMessageEventListener> listener = interface_cast<INexusHdmiCecMessageEventListener>(data.readStrongBinder());
        reply->writeInt32(setHdmiCecMessageEventListener(cecId, listener));
        return NO_ERROR;
    } break;

    case ADD_HDMI_HOTPLUG_EVENT_LISTENER: {
        uint32_t portId = data.readInt32();
        sp<INexusHdmiHotplugEventListener> listener = interface_cast<INexusHdmiHotplugEventListener>(data.readStrongBinder());
        reply->writeInt32(addHdmiHotplugEventListener(portId, listener));
        return NO_ERROR;
    } break;

    case REMOVE_HDMI_HOTPLUG_EVENT_LISTENER: {
        uint32_t portId = data.readInt32();
        sp<INexusHdmiHotplugEventListener> listener = interface_cast<INexusHdmiHotplugEventListener>(data.readStrongBinder());
        reply->writeInt32(removeHdmiHotplugEventListener(portId, listener));
        return NO_ERROR;
    } break;

    default:
        LOGE("ERROR! No such transaction(%d) in nexus service", code);
        return BBinder::onTransact(code, data, reply, flags);
        break;
    }/* switch(code) */

    return NO_ERROR;
}

