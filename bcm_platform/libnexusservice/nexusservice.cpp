/******************************************************************************
 *    (c)2010-2014 Broadcom Corporation
 * 
 * This program is the proprietary software of Broadcom Corporation and/or its licensors,
 * and may only be used, duplicated, modified or distributed pursuant to the terms and
 * conditions of a separate, written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized License, Broadcom grants
 * no license (express or implied), right to use, or waiver of any kind with respect to the
 * Software, and Broadcom expressly reserves all rights in and to the Software and all
 * intellectual property rights therein.  IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU
 * HAVE NO RIGHT TO USE THIS SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY
 * NOTIFY BROADCOM AND DISCONTINUE ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization, constitutes the valuable trade
 * secrets of Broadcom, and you shall use all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" 
 * AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES, REPRESENTATIONS OR 
 * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO 
 * THE SOFTWARE.  BROADCOM SPECIFICALLY DISCLAIMS ANY AND ALL IMPLIED WARRANTIES 
 * OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, 
 * LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION 
 * OR CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT OF 
 * USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR ITS 
 * LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR 
 * EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO YOUR 
 * USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF 
 * THE POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF THE AMOUNT 
 * ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE 
 * LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF ESSENTIAL PURPOSE OF 
 * ANY LIMITED REMEDY.
 *
 * $brcm_Workfile: nexusservice.cpp $
 * 
 *****************************************************************************/
  
//#define LOG_NDEBUG 0

#include <utils/Log.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <unistd.h>

#include <string.h>
#include <cutils/atomic.h>
#include <utils/Errors.h>
#include <binder/IServiceManager.h>
#include <utils/String16.h>
#include "cutils/properties.h"

#include "nexusservice.h"
#if NEXUS_HAS_CEC
#include "nexuscecservice.h"
#endif

#include "blst_list.h"
#include "nexus_audio_mixer.h"
#include "nexus_audio_decoder.h"
#include "nexus_audio_playback.h"
#include "nexus_video_decoder_extra.h"
#include "nexus_base_mmap.h"

#include "nexus_ipc_priv.h"

#ifdef LOG_TAG
#undef LOG_TAG
#endif
#define LOG_TAG "NexusService"

#ifdef UINT32_C
#undef UINT32_C
#define UINT32_C(x)  (x ## U)
#endif

/* We don't need to perform client reference counting for URSR14.1 or later */
#if defined(NEXUS_PLATFORM_VERSION_NUMBER) && defined(NEXUS_PLATFORM_VERSION) && (NEXUS_PLATFORM_VERSION_NUMBER < NEXUS_PLATFORM_VERSION(14,1)) || \
   !defined(NEXUS_PLATFORM_VERSION_NUMBER) || !defined(NEXUS_PLATFORM_VERSION)
#define MAX_CLIENTS 32
#define MAX_OBJECTS MAX_CLIENTS
#endif

/* The main heap normally has full access */
#ifdef NEXUS_PLATFORM_DEFAULT_HEAP
#define NEXUS_MAIN_HEAP_IDX NEXUS_PLATFORM_DEFAULT_HEAP
#else
#define NEXUS_MAIN_HEAP_IDX NEXUS_MEMC0_MAIN_HEAP
#endif 

BDBG_OBJECT_ID(NexusClientContext);

#if ANDROID_ENABLE_HDMI_HDCP
#include "nexus_hdmi_output.h"
#include "nexus_hdmi_output_hdcp.h"

/*****************/
/* For HDCP TESTING */
/* 1) insert the Production Key Set set generated by BCrypt */
/* 2) set the USE_PRODUCTION_KEYS macro to to 1 */
/*****************/
#define USE_PRODUCTION_KEYS 0
#if USE_PRODUCTION_KEYS
/*****************************/
/* INSERT PRODUCTION KeySet HERE */
/*****************************/
#else
/**************************************/
/* HDCP Specification Test Key Set */
/* */
/* NOTE: the default declared Test */
/* KeySet below is from the HDCP Spec */
/* and it *IS NOT* compatible with */
/* production devices */
/**************************************/

static NEXUS_HdmiOutputHdcpKsv hdcpTxAksv =
{ {0x14, 0xF7, 0x61, 0x03, 0xB7} };

static NEXUS_HdmiOutputHdcpKey encryptedTxKeySet[NEXUS_HDMI_OUTPUT_HDCP_NUM_KEYS] =
{
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x691e138f, 0x58a44d00},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x0950e658, 0x35821f00},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x0d98b9ab, 0x476a8a00},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xcac5cb52, 0x1b18f300},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xb4d89668, 0x7f14fb00},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x818f4878, 0xc98be000},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x412c11c8, 0x64d0a000},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x44202428, 0x5a9db300},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x6b56adbd, 0xb228b900},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xf6e46c4a, 0x7ba49100},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x589d5e20, 0xf8005600},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xa03fee06, 0xb77f8c00},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x28bc7c9d, 0x8c2dc000},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x059f4be5, 0x61125600},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xcbc1ca8c, 0xdef07400},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x6adbfc0e, 0xf6b83b00},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xd72fb216, 0xbb2ba000},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x98547846, 0x8e2f4800},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x38472762, 0x25ae6600},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xf2dd23a3, 0x52493d00},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x543a7b76, 0x31d2e200},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x2561e6ed, 0x1a584d00},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xf7227bbf, 0x82603200},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x6bce3035, 0x461bf600},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x6b97d7f0, 0x09043600},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xf9498d61, 0x05e1a100},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x063405d1, 0x9d8ec900},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x90614294, 0x67c32000},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xc34facce, 0x51449600},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x8a8ce104, 0x45903e00},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xfc2d9c57, 0x10002900},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x80b1e569, 0x3b94d700},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x437bdd5b, 0xeac75400},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xba90c787, 0x58fb7400},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xe01d4e36, 0xfa5c9300},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xae119a15, 0x5e070300},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x01fb788a, 0x40d30500},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xb34da0d7, 0xa5590000},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x409e2c4a, 0x633b3700},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x412056b4, 0xbb732500}
} ;
#endif

/*
  from HDCP Spec:
  Table 51 gives the format of the HDCP SRM. All values are stored in big endian format.

  Specify KSVs here in big endian;
*/
#define NUM_REVOKED_KSVS 3
static uint8_t NumRevokedKsvs = NUM_REVOKED_KSVS ;
static const NEXUS_HdmiOutputHdcpKsv RevokedKsvs[NUM_REVOKED_KSVS] =
{
    /* MSB ... LSB */
    {{0xa5, 0x1f, 0xb0, 0xc3, 0x72}},
    {{0x65, 0xbf, 0x04, 0x8a, 0x7c}},
    {{0x65, 0x65, 0x1e, 0xd5, 0x64}}
} ;

static void hotplugCallback(void *pParam, int iParam)
{
    NEXUS_HdmiOutputStatus status;
    NEXUS_HdmiOutputHandle hdmi = (NEXUS_HdmiOutputHandle)pParam;
    NEXUS_DisplayHandle display = (NEXUS_DisplayHandle)iParam;
    NEXUS_DisplaySettings displaySettings;
    NEXUS_HdmiOutputSettings hdmiSettings;

    NEXUS_HdmiOutput_GetStatus(hdmi, &status);
    /* the app can choose to switch to the preferred format, but it's not required. */
    if ( !status.connected ) {
        LOGE("No RxDevice Connected") ;
        return ;
    }

    NEXUS_Display_GetSettings(display, &displaySettings);
    if ( !status.videoFormatSupported[displaySettings.format] ) {
        LOGE("Current format not supported by attached monitor. Switching to preferred format %d", status.preferredVideoFormat) ;
        displaySettings.format = status.preferredVideoFormat;
    }
    NEXUS_Display_SetSettings(display, &displaySettings);

    /* force HDMI updates after a hotplug */
    NEXUS_HdmiOutput_GetSettings(hdmi, &hdmiSettings) ;
    NEXUS_HdmiOutput_SetSettings(hdmi, &hdmiSettings) ;

    /* restart HDCP if it was previously enabled */
    NEXUS_HdmiOutput_StartHdcpAuthentication(hdmi);
}

static void hdmiOutputHdcpStateChanged(void *pContext, int param)
{
    bool success = false ;
    NEXUS_HdmiOutputHandle handle = (NEXUS_HdmiOutputHandle)pContext;
    NEXUS_HdmiOutputHdcpStatus hdcpStatus;

    BSTD_UNUSED(param) ;

    NEXUS_HdmiOutput_GetHdcpStatus(handle, &hdcpStatus);
    switch (hdcpStatus.hdcpError) {
    case NEXUS_HdmiOutputHdcpError_eSuccess :
        LOGE("HDCP Authentication Successful\n");
        success = true ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eRxBksvError :
        LOGE("HDCP Rx BKsv Error") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eRxBksvRevoked :
        LOGE("HDCP Rx BKsv/Keyset Revoked") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eRxBksvI2cReadError :
    case NEXUS_HdmiOutputHdcpError_eTxAksvI2cWriteError :
        LOGE("HDCP I2C Read Error") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eTxAksvError :
        LOGE("HDCP Tx Aksv Error") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eReceiverAuthenticationError :
        LOGE("HDCP Receiver Authentication Failure") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eRepeaterAuthenticationError :
    case NEXUS_HdmiOutputHdcpError_eRepeaterLinkFailure : /* Repeater Error; unused */
        LOGE("HDCP Repeater Authentication Failure") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eRxDevicesExceeded :
        LOGE("HDCP Repeater MAX Downstram Devices Exceeded") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eRepeaterDepthExceeded :
        LOGE("HDCP Repeater MAX Downstram Levels Exceeded") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eRepeaterFifoNotReady :
        LOGE("Timeout waiting for Repeater") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eRepeaterDeviceCount0 : /* unused */
        break ;

    case NEXUS_HdmiOutputHdcpError_eLinkRiFailure :
        LOGE("HDCP Ri Integrity Check Failure") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eLinkPjFailure :
        LOGE("HDCP Pj Integrity Check Failure") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eFifoUnderflow :
    case NEXUS_HdmiOutputHdcpError_eFifoOverflow :
        LOGE("Video configuration issue") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eMultipleAnRequest : /* Should not reach here; but flag if occurs */
        LOGE("Multiple Authentication Request... ") ;

    default :
        LOGE("Unknown HDCP Authentication Error %d", hdcpStatus.hdcpError) ;
    }

    if (!success) {
        LOGE("\nHDCP Authentication Failed. Current State %d\n", hdcpStatus.hdcpState);
        /* always retry */
        NEXUS_HdmiOutput_StartHdcpAuthentication(handle);
    }
}

static void initializeHdmiOutputHdcpSettings(int index)
{
    NEXUS_HdmiOutputHdcpSettings hdmiOutputHdcpSettings;

    NEXUS_PlatformConfiguration platformConfig;

    NEXUS_Platform_GetConfiguration(&platformConfig);
    NEXUS_HdmiOutput_GetHdcpSettings(platformConfig.outputs.hdmi[index], &hdmiOutputHdcpSettings);

    /* copy the encrypted key set and its Aksv here */
    BKNI_Memcpy(hdmiOutputHdcpSettings.encryptedKeySet, encryptedTxKeySet, NEXUS_HDMI_OUTPUT_HDCP_NUM_KEYS * sizeof(NEXUS_HdmiOutputHdcpKey)) ;
    BKNI_Memcpy(&hdmiOutputHdcpSettings.aksv, &hdcpTxAksv, NEXUS_HDMI_OUTPUT_HDCP_KSV_LENGTH) ;

    /* install HDCP success callback */
    hdmiOutputHdcpSettings.successCallback.callback = hdmiOutputHdcpStateChanged ;
    hdmiOutputHdcpSettings.successCallback.context = platformConfig.outputs.hdmi[index];

    /* install HDCP failure callback */
    hdmiOutputHdcpSettings.failureCallback.callback = hdmiOutputHdcpStateChanged ;
    hdmiOutputHdcpSettings.failureCallback.context = platformConfig.outputs.hdmi[index];

    NEXUS_HdmiOutput_SetHdcpSettings(platformConfig.outputs.hdmi[index], &hdmiOutputHdcpSettings);

    /* install list of revoked KSVs from SRMs (System Renewability Message) if available */
    NEXUS_HdmiOutput_SetHdcpRevokedKsvs(platformConfig.outputs.hdmi[index], RevokedKsvs, NumRevokedKsvs) ;
}
#endif

typedef struct NexusClientContext {
    BDBG_OBJECT(NexusClientContext)
    BLST_D_ENTRY(NexusClientContext) link;
    struct {
        NEXUS_ClientHandle nexusClient;
        unsigned connectId;
    } ipc;
    struct {
        NEXUS_SurfaceClientHandle       graphicsSurface;
        NEXUS_SurfaceClientHandle       videoSurface;
        struct {
            bool                            connected;
#if NEXUS_HAS_HDMI_INPUT
            NEXUS_HdmiInputHandle           handle;
#endif
#if NEXUS_NUM_AUDIO_INPUT_CAPTURES
            NEXUS_AudioInputCaptureHandle   captureInput;
#endif
            unsigned                        windowId;
        } hdmiInput;
    } resources;
    b_refsw_client_client_info info;
    b_refsw_client_client_configuration createConfig;
} NexusClientContext;

typedef struct NexusServerContext {
    NexusServerContext();
    ~NexusServerContext() {};

    Mutex mLock;
    unsigned mJoinRefCount;
    BLST_D_HEAD(b_refsw_client_list, NexusClientContext) clients;
#if NEXUS_HAS_HDMI_OUTPUT
    sp<INexusHdmiHotplugEventListener> mHdmiHotplugEventListener[NEXUS_NUM_HDMI_OUTPUTS];
#endif

    struct {
        unsigned client;
        NEXUS_SurfaceCompositorClientId surfaceClientId;
    } lastId;
} NexusServerContext;

NexusServerContext::NexusServerContext() : mLock(Mutex::SHARED), mJoinRefCount(0)
{
    BLST_D_INIT(&clients);
    lastId.client = 0;
    lastId.surfaceClientId = 0;
}

const String16 INexusService::descriptor(NEXUS_INTERFACE_NAME);

String16 INexusService::getInterfaceDescriptor() {
        return INexusService::descriptor;
}

NEXUS_ClientHandle NexusService::getNexusClient(NexusClientContext * client)
{
    NEXUS_ClientHandle nexusClient = NULL;
    NEXUS_InterfaceName interfaceName;
    unsigned num;
    unsigned i;
    int rc;

    if (client == NULL) {
        LOGE("%s: client context is NULL!!!", __PRETTY_FUNCTION__);
    }
    else {
        NEXUS_Platform_GetDefaultInterfaceName(&interfaceName);
        strcpy(interfaceName.name, "NEXUS_Client");
#ifndef MAX_OBJECTS
        rc = NEXUS_Platform_GetObjects(&interfaceName, NULL, 0, &num);
        BDBG_ASSERT(!rc);
        NEXUS_PlatformObjectInstance objects[num];
#else
        NEXUS_PlatformObjectInstance objects[MAX_OBJECTS];
        num = MAX_OBJECTS;
#endif
        rc = NEXUS_Platform_GetObjects(&interfaceName, objects, num, &num);
        BDBG_ASSERT(!rc);

        for (i=0; i < num; i++) {
            NEXUS_ClientStatus status;
            unsigned j;
            rc = NEXUS_Platform_GetClientStatus(reinterpret_cast<NEXUS_ClientHandle>(objects[i].object), &status);
            if (rc) continue;

            if (status.pid == client->createConfig.pid) {
                nexusClient = reinterpret_cast<NEXUS_ClientHandle>(objects[i].object);
                LOGV("%s: Found client \"%s\" with PID %d nexus_client %p.", __PRETTY_FUNCTION__,
                    client->createConfig.name.string, client->createConfig.pid, (void *)nexusClient);
                break;
            }
        }
    }
    return nexusClient;
}

int NexusService::platformInitAudio(void)
{
    int i;
    int rc = 0;
    NEXUS_PlatformConfiguration             platformConfig;
    NEXUS_AudioPlaybackOpenSettings         simpleAudioDecoderOpenSettings;
    NEXUS_SimpleAudioDecoderServerSettings  simpleAudioDecoderSettings;
    NEXUS_SimpleAudioPlaybackServerSettings simpleAudioPlaybackSettings;
    NEXUS_AudioDecoderOpenSettings          audioDecoderOpenSettings;

    NEXUS_Platform_GetConfiguration(&platformConfig);

    /* create audio decoders */
    for (i=0; i<MAX_AUDIO_DECODERS; i++) {
        NEXUS_AudioDecoder_GetDefaultOpenSettings(&audioDecoderOpenSettings);
        audioDecoderOpenSettings.fifoSize = AUDIO_DECODER_FIFO_SIZE;
        audioDecoderOpenSettings.type     = NEXUS_AudioDecoderType_eDecode;
        audioDecoder[i] = NEXUS_AudioDecoder_Open(i, &audioDecoderOpenSettings);
        if (audioDecoder[i] == NULL) {
            LOGE("%s: Could not open audio decoder %d!!!", __PRETTY_FUNCTION__, i);
            return NEXUS_UNKNOWN;
        }
    }
    
    /* open audio mixer */
    mixer = NEXUS_AudioMixer_Open(NULL);
    if (mixer == NULL) {
        LOGE("%s: Could not open audio mixer!!!", __PRETTY_FUNCTION__);
        return NEXUS_UNKNOWN;
    }

    NEXUS_AudioPlayback_GetDefaultOpenSettings(&simpleAudioDecoderOpenSettings);
    simpleAudioDecoderOpenSettings.heap = platformConfig.heap[NEXUS_MAIN_HEAP_IDX]; /* eFull mapping */

    /* open the audio playback */
    for (i=0; i<MAX_AUDIO_PLAYBACKS; i++) {
        audioPlayback[i] = NEXUS_AudioPlayback_Open(i, &simpleAudioDecoderOpenSettings);
        if (audioPlayback[i] == NULL) {
            LOGE("%s: Could not open audio playback %d!!!", __PRETTY_FUNCTION__, i);
            return NEXUS_UNKNOWN;
        }
    }

    /* Connect audio inputs to the mixer and mixer to the outputs */
    if (MAX_AUDIO_DECODERS > 0) {
        rc = NEXUS_AudioMixer_AddInput(mixer, NEXUS_AudioDecoder_GetConnector(audioDecoder[0], NEXUS_AudioDecoderConnectorType_eStereo));
        if (rc) {
            LOGE("%s: Could not add audio decoder 0 to audio mixer!!!", __PRETTY_FUNCTION__);
            return NEXUS_UNKNOWN;
        }
        if (MAX_AUDIO_DECODERS > 1) {
            rc = NEXUS_AudioMixer_AddInput(mixer, NEXUS_AudioDecoder_GetConnector(audioDecoder[1], NEXUS_AudioDecoderConnectorType_eStereo));
            if (rc) {
                LOGE("%s: Could not add audio decoder 1 to audio mixer!!!", __PRETTY_FUNCTION__);
                return NEXUS_UNKNOWN;
            }
        }
    }
    
    if (MAX_AUDIO_PLAYBACKS > 0) {
        rc = NEXUS_AudioMixer_AddInput(mixer, NEXUS_AudioPlayback_GetConnector(audioPlayback[0]));
        if (rc) {
            LOGE("%s: Could not add audio playback 0 to audio mixer!!!", __PRETTY_FUNCTION__);
            return NEXUS_UNKNOWN;
        }
        if (MAX_AUDIO_PLAYBACKS > 1) {
            rc = NEXUS_AudioMixer_AddInput(mixer, NEXUS_AudioPlayback_GetConnector(audioPlayback[1]));
            if (rc) {
                LOGE("%s: Could not add audio playback 1 to audio mixer!!!", __PRETTY_FUNCTION__);
                return NEXUS_UNKNOWN;
            }
        }
    }

#if NEXUS_NUM_AUDIO_DACS
    rc = NEXUS_AudioOutput_AddInput(NEXUS_AudioDac_GetConnector(platformConfig.outputs.audioDacs[0]), NEXUS_AudioMixer_GetConnector(mixer));
    if (rc) {
        LOGE("%s: Could not add audio mixer to dacs 0 output!!!", __PRETTY_FUNCTION__);
        return NEXUS_UNKNOWN;
    }
#endif
#if NEXUS_HAS_HDMI_OUTPUT && NEXUS_NUM_HDMI_OUTPUTS
    rc = NEXUS_AudioOutput_AddInput(NEXUS_HdmiOutput_GetAudioConnector(platformConfig.outputs.hdmi[0]), NEXUS_AudioMixer_GetConnector(mixer));
    if (rc) {
        LOGE("%s: Could not add audio mixer to HDMI 0 output!!!", __PRETTY_FUNCTION__);
        return NEXUS_UNKNOWN;
    }
#endif
#if NEXUS_NUM_SPDIF_OUTPUTS 
    rc = NEXUS_AudioOutput_AddInput(NEXUS_SpdifOutput_GetConnector(platformConfig.outputs.spdif[0]), NEXUS_AudioMixer_GetConnector(mixer));
    if (rc) {
        LOGE("%s: Could not add audio mixer to SPDIF 0 output!!!", __PRETTY_FUNCTION__);
        return NEXUS_UNKNOWN;
    }
#endif

    /* create simple audio decoder */
    for (i=0; i<MAX_AUDIO_DECODERS; i++) {
        NEXUS_SimpleAudioDecoder_GetDefaultServerSettings(&simpleAudioDecoderSettings);
        simpleAudioDecoderSettings.primary = audioDecoder[i];
#if NEXUS_HAS_HDMI_OUTPUT && NEXUS_NUM_HDMI_OUTPUTS
        simpleAudioDecoderSettings.hdmi.outputs[0] = platformConfig.outputs.hdmi[0];
#endif
        simpleAudioDecoderSettings.stcIndex = i;  /* Must set this to be able to do STC trick modes! */
        simpleAudioDecoder[i] = NEXUS_SimpleAudioDecoder_Create(i, &simpleAudioDecoderSettings);
        if (simpleAudioDecoder[i] == NULL) {
            LOGE("%s: Could not open simple audio decoder %d!!!", __PRETTY_FUNCTION__, i);
            return NEXUS_UNKNOWN;
        }
    }

    /* create simple audio player */
    for (i=0; i<MAX_AUDIO_PLAYBACKS; i++) {
        NEXUS_SimpleAudioPlayback_GetDefaultServerSettings(&simpleAudioPlaybackSettings);
        simpleAudioPlaybackSettings.decoder = simpleAudioDecoder[i]; /* linked to the audio decoder for StcChannel */
        simpleAudioPlaybackSettings.playback = audioPlayback[i];
        simpleAudioPlayback[i] = NEXUS_SimpleAudioPlayback_Create(i, &simpleAudioPlaybackSettings);
        if (simpleAudioPlayback[i] == NULL) {
            LOGE("%s: Could not open simple audio playback %d!!!", __PRETTY_FUNCTION__, i);
            return NEXUS_UNKNOWN;
        }
    }
    return rc;
}

void NexusService::setAudioState(bool enable)
{
    int i;
    NEXUS_SimpleAudioDecoderServerSettings simpleAudioDecoderSettings;
    NEXUS_SimpleAudioPlaybackServerSettings simpleAudioPlaybackSettings;
    
    /* Enable/Disable simple audio player */
    for (i=0; i<MAX_AUDIO_PLAYBACKS; i++) {
        NEXUS_SimpleAudioPlayback_GetServerSettings(simpleAudioPlayback[i], &simpleAudioPlaybackSettings);
        if (enable) {
            simpleAudioPlaybackSettings.decoder = simpleAudioDecoder[i]; /* linked to the audio decoder for StcChannel */
            simpleAudioPlaybackSettings.playback = audioPlayback[i];
        } else {
            simpleAudioPlaybackSettings.decoder = NULL;
            simpleAudioPlaybackSettings.playback = NULL;
        }
        NEXUS_SimpleAudioPlayback_SetServerSettings(simpleAudioPlayback[i], &simpleAudioPlaybackSettings);
    }

    /* Enable/Disable simple audio decoder */
    for (i=0; i<MAX_AUDIO_DECODERS; i++) {
        NEXUS_SimpleAudioDecoder_GetServerSettings(simpleAudioDecoder[i], &simpleAudioDecoderSettings);
        simpleAudioDecoderSettings.enabled = enable;
        NEXUS_SimpleAudioDecoder_SetServerSettings(simpleAudioDecoder[i], &simpleAudioDecoderSettings);
    }
}

void NexusService::hotplugCallback(void *context __unused, int param __unused)
{
#if NEXUS_HAS_HDMI_OUTPUT
    NexusService *pNexusService = reinterpret_cast<NexusService *>(context);

    LOGV("%s: HDMI %d hotplug called!", __PRETTY_FUNCTION__, param);

    if (pNexusService->server->mHdmiHotplugEventListener[param] != NULL) {
        b_hdmiOutputStatus status;

        if (pNexusService->getHdmiOutputStatus(param, &status) == true) {
            LOGV("%s: Firing off HDMI%d hotplug %s event...", __PRETTY_FUNCTION__, param, status.connected ? "connected" : "disconnected");
            pNexusService->server->mHdmiHotplugEventListener[param]->onHdmiHotplugEventReceived(param, status.connected);
        }
    }
#endif
}

int NexusService::platformInitHdmiOutputs()
{
    int rc = 0;
#if NEXUS_HAS_HDMI_OUTPUT
    for (int index = 0; index < NEXUS_NUM_HDMI_OUTPUTS; index++) {
        NEXUS_PlatformConfiguration platformConfig;
        NEXUS_HdmiOutputHandle      hdmiOutput;
        NEXUS_HdmiOutputSettings    hdmiSettings;

        NEXUS_Platform_GetConfiguration(&platformConfig);
        hdmiOutput = platformConfig.outputs.hdmi[index];
        NEXUS_HdmiOutput_GetSettings(hdmiOutput, &hdmiSettings);
        hdmiSettings.hotplugCallback.callback = hotplugCallback;
        hdmiSettings.hotplugCallback.context = this;
        hdmiSettings.hotplugCallback.param = index;
        rc = NEXUS_HdmiOutput_SetSettings(hdmiOutput, &hdmiSettings);
        if (rc) {
            ALOGE("%s: Could not set HDMI%d output settings!!!", __PRETTY_FUNCTION__, index);
        }
    }
#endif
    return rc;
}

void NexusService::platformUninitHdmiOutputs()
{
#if NEXUS_HAS_HDMI_OUTPUT
    for (int index = 0; index < NEXUS_NUM_HDMI_OUTPUTS; index++) {
        NEXUS_PlatformConfiguration platformConfig;
        NEXUS_HdmiOutputHandle      hdmiOutput;
        NEXUS_HdmiOutputSettings    hdmiSettings;

        NEXUS_Platform_GetConfiguration(&platformConfig);
        hdmiOutput = platformConfig.outputs.hdmi[index];
        NEXUS_HdmiOutput_GetSettings(hdmiOutput, &hdmiSettings);
        hdmiSettings.hotplugCallback.callback = NULL;
        hdmiSettings.hotplugCallback.context = NULL;
        hdmiSettings.hotplugCallback.param = 0;
        if (NEXUS_HdmiOutput_SetSettings(hdmiOutput, &hdmiSettings)) {
            ALOGE("%s: Could not set HDMI%d output settings!!!", __PRETTY_FUNCTION__, index);
        }
    }
#endif
}

int NexusService::platformInitVideo(void)
{
    NEXUS_DisplaySettings           displaySettings;        
    NEXUS_PlatformConfiguration     platformConfig;
    NEXUS_VideoDecoderOpenSettings  videoDecoderOpenSettings;
    int rc = 0;
    
    NEXUS_Platform_GetConfiguration(&platformConfig);
    
    /* Init displays */
    for(int j=0; j<MAX_NUM_DISPLAYS; j++) {
        NEXUS_Display_GetDefaultSettings(&displaySettings);
        displaySettings.displayType = NEXUS_DisplayType_eAuto;
        displaySettings.format = (j == HD_DISPLAY) ? initial_hd_format : initial_sd_format;       
        displayState[j].display = NEXUS_Display_Open(j, &displaySettings);
        if (!displayState[j].display) {
            LOGE("%s: NEXUS_Display_Open(%d) failed!!", __PRETTY_FUNCTION__, j);
            return NEXUS_UNKNOWN;
        }
        displayState[j].hNexusDisplay = reinterpret_cast<int>(displayState[j].display);
    }
    
#if NEXUS_NUM_COMPONENT_OUTPUTS
    /* Add Component Output to the HD-Display */
    rc = NEXUS_Display_AddOutput(displayState[HD_DISPLAY].display, NEXUS_ComponentOutput_GetConnector(platformConfig.outputs.component[0]));
    if (rc!=NEXUS_SUCCESS) {
        LOGE("%s: NEXUS_Display_AddOutput(component) failed!!", __PRETTY_FUNCTION__);
        return rc;
    }
#endif

#if NEXUS_HAS_HDMI_OUTPUT && NEXUS_NUM_HDMI_OUTPUTS
    /* Add HDMI Output to the HD-Display */
    rc = NEXUS_Display_AddOutput(displayState[HD_DISPLAY].display, NEXUS_HdmiOutput_GetVideoConnector(platformConfig.outputs.hdmi[0]));
    if (rc!=NEXUS_SUCCESS) {
        LOGE("%s: NEXUS_Display_AddOutput(hdmi) failed!!", __PRETTY_FUNCTION__);
        return rc;
    }
#endif

#if NEXUS_NUM_COMPOSITE_OUTPUTS
    if (MAX_NUM_DISPLAYS > 1) {
        /* Add Composite Output to the SD-Display */
        rc = NEXUS_Display_AddOutput(displayState[SD_DISPLAY].display, NEXUS_CompositeOutput_GetConnector(platformConfig.outputs.composite[0]));
        if (rc!=NEXUS_SUCCESS) {
            LOGE("%s: NEXUS_Display_AddOutput(composite) failed!!", __PRETTY_FUNCTION__);
            return rc;
        }
    }
#endif
    
    // Both HD and SD displays have 2 video windows each 
    for (int j=0; j<MAX_NUM_DISPLAYS; j++) {
        for (int i=0; i<MAX_VIDEO_WINDOWS_PER_DISPLAY; i++) {
            displayState[j].video_window[i] = NEXUS_VideoWindow_Open(displayState[j].display, i);
            if (!displayState[j].video_window[i]) {
                LOGE("%s: NEXUS_VideoWindow_Open(%d) failed!!", __PRETTY_FUNCTION__, i);
                return NEXUS_UNKNOWN;
            }
            displayState[j].hNexusVideoWindow[i] = reinterpret_cast<int>(displayState[j].video_window[i]);
        }
    }
    
    for (int i=0; i<MAX_VIDEO_DECODERS; i++) {
        NEXUS_SimpleVideoDecoderServerSettings settings;

        // open video decoder
        NEXUS_VideoDecoder_GetDefaultOpenSettings(&videoDecoderOpenSettings);
        videoDecoderOpenSettings.fifoSize = VIDEO_DECODER_FIFO_SIZE;
        if (i == 0) {
            videoDecoderOpenSettings.svc3dSupported = true;
        }

        videoDecoder[i] = NEXUS_VideoDecoder_Open(i, &videoDecoderOpenSettings); 
        if (!videoDecoder[i]) {
            LOGE("%s: NEXUS_VideoDecoder_Open(%d) failed!!", __PRETTY_FUNCTION__, i);
            return NEXUS_UNKNOWN;
        }

        NEXUS_VideoDecoderSettings videoDecoderSettings;
        NEXUS_PlatformSettings     platformSettings;
        NEXUS_Platform_GetSettings(&platformSettings);
        if ((i==0) && (platformSettings.videoDecoderModuleSettings.supportedCodecs[NEXUS_VideoCodec_eH265])) {
            NEXUS_VideoDecoder_GetSettings(videoDecoder[i], &videoDecoderSettings);
            videoDecoderSettings.supportedCodecs[NEXUS_VideoCodec_eH265] = true;
            videoDecoderSettings.maxWidth  = 3840; 
            videoDecoderSettings.maxHeight = 2160;
            NEXUS_VideoDecoder_SetSettings(videoDecoder[i], &videoDecoderSettings);
        }

        // create simple video decoder 
        NEXUS_SimpleVideoDecoder_GetDefaultServerSettings(&settings);
        settings.videoDecoder = videoDecoder[i];
        settings.window[0] = NULL;
        settings.stcIndex = i;  /* Must set this to be able to do STC trick modes! */
        simpleVideoDecoder[i] = NEXUS_SimpleVideoDecoder_Create(i, &settings);
        if (!simpleVideoDecoder[i]) {
            LOGE("%s: NEXUS_SimpleVideoDecoder_Open(%d) failed!!", __PRETTY_FUNCTION__, i);
            return NEXUS_UNKNOWN;
        }

        //
        // by default give video_window to the simplevideodecoder
        // Note: simplevideodecoder_start will connect videodecoder to the videowindow
        // later if we want to disconnect and connect other videoinput (say, HDMI-input)
        // stop simplevideodecoder, set below to NULL and add new videoinput explicitly 
        // to the video window.
        //
        NEXUS_SimpleVideoDecoder_GetServerSettings(simpleVideoDecoder[i], &settings);
        for (int j=0; j<MAX_NUM_DISPLAYS; j++) {
            settings.window[j] = displayState[j].video_window[i >= MAX_VIDEO_WINDOWS_PER_DISPLAY ? MAX_VIDEO_WINDOWS_PER_DISPLAY-1 : i];
        }
        NEXUS_SimpleVideoDecoder_SetServerSettings(simpleVideoDecoder[i], &settings);
    }

#if ANDROID_ENABLE_HDMI_HDCP
    for (int i=0; i < NEXUS_NUM_HDMI_OUTPUTS; i++) {
        /* Install hotplug callback -- video only for now */
        NEXUS_HdmiOutputSettings hdmiSettings;

        NEXUS_HdmiOutput_GetSettings(platformConfig.outputs.hdmi[i], &hdmiSettings);
        hdmiSettings.hotplugCallback.callback = hotplugCallback;
        hdmiSettings.hotplugCallback.context = platformConfig.outputs.hdmi[i];
        hdmiSettings.hotplugCallback.param = i;
        NEXUS_HdmiOutput_SetSettings(platformConfig.outputs.hdmi[i], &hdmiSettings);

        /* initalize HDCP settings, keys, etc. */
        initializeHdmiOutputHdcpSettings(i) ;
        NEXUS_HdmiOutput_StartHdcpAuthentication(platformConfig.outputs.hdmi[i]);
    }
#endif

    return rc;
}

void NexusService::setVideoState(bool enable)
{
    for(int i=0; i<MAX_VIDEO_DECODERS; i++)
    {
        NEXUS_SimpleVideoDecoderServerSettings settings;

        NEXUS_SimpleVideoDecoder_GetServerSettings(simpleVideoDecoder[i], &settings);
        settings.enabled = enable;
        NEXUS_SimpleVideoDecoder_SetServerSettings(simpleVideoDecoder[i], &settings);
    }
    return;
}

void framebuffer_callback(void *context, int param)
{
    BSTD_UNUSED(context);
    BSTD_UNUSED(param);
}

static BKNI_EventHandle inactiveEvent;
static void inactive_callback(void *context, int param)
{    
    BSTD_UNUSED(param);    
    BKNI_SetEvent((BKNI_EventHandle)context);
}

/* Event callback that will be called when a gfx op is complete */
static void complete(void *data, int unused)
{
    BSTD_UNUSED(unused);
    BKNI_SetEvent((BKNI_EventHandle)data);
}

int NexusService::platformInitSurfaceCompositor(void)
{
    NEXUS_SurfaceCreateSettings createSettings;
    int rc=0; unsigned i;
    NEXUS_SurfaceCompositorSettings *p_surface_compositor_settings = NULL;
    NEXUS_VideoFormatInfo formatInfo;
    NEXUS_VideoFormat_GetInfo(initial_hd_format, &formatInfo);
            
    BKNI_CreateEvent(&inactiveEvent);
    p_surface_compositor_settings = (NEXUS_SurfaceCompositorSettings *)BKNI_Malloc(sizeof(NEXUS_SurfaceCompositorSettings));
    if (NULL == p_surface_compositor_settings) {
        LOGE("%s:%d BKNI_Malloc failed",__PRETTY_FUNCTION__,__LINE__);
        return NEXUS_OUT_OF_DEVICE_MEMORY;
    }

    /* create surface compositor server */    
    surface_compositor = NEXUS_SurfaceCompositor_Create(0);
    if (surface_compositor == NULL) {
        LOGE("%s: Could not create Surface Compositor 0!!!", __PRETTY_FUNCTION__);
        return NEXUS_UNKNOWN;
    }
    NEXUS_SurfaceCompositor_GetSettings(surface_compositor, p_surface_compositor_settings);
    NEXUS_Display_GetGraphicsSettings(displayState[HD_DISPLAY].display, &p_surface_compositor_settings->display[HD_DISPLAY].graphicsSettings);
    // Give space for videowindows to change zorder without using same one twice
    p_surface_compositor_settings->display[HD_DISPLAY].graphicsSettings.zorder = MAX_VIDEO_WINDOWS_PER_DISPLAY + 1;
    p_surface_compositor_settings->display[HD_DISPLAY].graphicsSettings.enabled = true;
    p_surface_compositor_settings->display[HD_DISPLAY].display = displayState[HD_DISPLAY].display;
    p_surface_compositor_settings->display[HD_DISPLAY].framebuffer.number = 2;
    p_surface_compositor_settings->display[HD_DISPLAY].framebuffer.width = formatInfo.width;
    p_surface_compositor_settings->display[HD_DISPLAY].framebuffer.height = formatInfo.height;
    p_surface_compositor_settings->display[HD_DISPLAY].framebuffer.backgroundColor = 0; /* black background */
    p_surface_compositor_settings->display[HD_DISPLAY].framebuffer.heap = NEXUS_Platform_GetFramebufferHeap(0);
#if 0
    // give HD video windows to NSC
    for(i=0; i<MAX_VIDEO_WINDOWS_PER_DISPLAY; i++)
    {
        p_surface_compositor_settings->display[HD_DISPLAY].window[i].window = displayState[HD_DISPLAY].video_window[i];
        if(displayState[HD_DISPLAY].video_window[i])
            NEXUS_VideoWindow_GetSettings(displayState[HD_DISPLAY].video_window[i], &p_surface_compositor_settings->display[HD_DISPLAY].window[i].settings);
    }
#endif

    if((NEXUS_VideoFormat_e720p_3DOU_AS == initial_hd_format) || (NEXUS_VideoFormat_e1080p24hz_3DOU_AS == initial_hd_format)) {
        p_surface_compositor_settings->display[HD_DISPLAY].display3DSettings.overrideOrientation = true;
        p_surface_compositor_settings->display[HD_DISPLAY].display3DSettings.orientation = NEXUS_VideoOrientation_e2D;
    }
    if(MAX_NUM_DISPLAYS > 1) {
        NEXUS_Display_GetGraphicsSettings(displayState[SD_DISPLAY].display, &p_surface_compositor_settings->display[SD_DISPLAY].graphicsSettings);
        p_surface_compositor_settings->display[SD_DISPLAY].graphicsSettings.enabled = true;
        p_surface_compositor_settings->display[SD_DISPLAY].display = displayState[SD_DISPLAY].display;
        NEXUS_VideoFormat_GetInfo(initial_sd_format, &formatInfo);
        p_surface_compositor_settings->display[SD_DISPLAY].framebuffer.width = formatInfo.width;
        p_surface_compositor_settings->display[SD_DISPLAY].framebuffer.height = formatInfo.height;
        p_surface_compositor_settings->display[SD_DISPLAY].framebuffer.backgroundColor = 0; /* black background */
        p_surface_compositor_settings->display[SD_DISPLAY].framebuffer.heap = NEXUS_Platform_GetFramebufferHeap(1);
#if 0
        // give SD video windows to NSC
        for(i=0; i<MAX_VIDEO_WINDOWS_PER_DISPLAY; i++)
        {
            p_surface_compositor_settings->display[SD_DISPLAY].window[i].window = displayState[SD_DISPLAY].video_window[i];
            if(displayState[SD_DISPLAY].video_window[i])
                NEXUS_VideoWindow_GetSettings(displayState[SD_DISPLAY].video_window[i], &p_surface_compositor_settings->display[SD_DISPLAY].window[i].settings);
        }
#endif
    }
    p_surface_compositor_settings->frameBufferCallback.callback = framebuffer_callback;
    p_surface_compositor_settings->frameBufferCallback.context = surface_compositor;
    p_surface_compositor_settings->inactiveCallback.callback = inactive_callback;
    p_surface_compositor_settings->inactiveCallback.context = inactiveEvent;
    rc = NEXUS_SurfaceCompositor_SetSettings(surface_compositor, p_surface_compositor_settings);
    if (rc) {
        LOGE("%s:%d NSC_SetSettings failed",__PRETTY_FUNCTION__,__LINE__);
    }
    else {
        if (p_surface_compositor_settings)
            BKNI_Free(p_surface_compositor_settings);
    }
    return rc;
}

void NexusService::platformInit()
{
    NEXUS_Error rc;
    int i=0;
    char value[PROPERTY_VALUE_MAX];
    NEXUS_Graphics2DSettings        gfxSettings;
    NEXUS_PlatformConfiguration platformConfig;
    NEXUS_PlatformStartServerSettings serverSettings;

    NEXUS_Platform_GetConfiguration(&platformConfig);
    NEXUS_Platform_GetDefaultStartServerSettings(&serverSettings);

    LOGI("***************************\n\tStarting server in mode %d \n***************************", ANDROID_CLIENT_SECURITY_MODE);

    serverSettings.allowUnprotectedClientsToCrash = true;
    serverSettings.allowUnauthenticatedClients = false;

    rc = NEXUS_Platform_StartServer(&serverSettings);
    if (rc != NEXUS_SUCCESS) {
        LOGE("%s:NEXUS_Platform_StartServer Failed (rc=%d)!\n", __PRETTY_FUNCTION__, rc);
        BDBG_ASSERT(rc == NEXUS_SUCCESS);
    }

    for (i=0; i<MAX_NUM_DISPLAYS; i++) {
        BKNI_Memset(&displayState[i], 0, sizeof(DisplayState));
    }

    for (i=0; i<MAX_AUDIO_DECODERS; i++) {
        audioDecoder[i] = NULL;
        simpleAudioDecoder[i] = NULL;
    }

    for (i=0; i<MAX_AUDIO_PLAYBACKS; i++) {
        audioPlayback[i] = NULL;
        simpleAudioPlayback[i] = NULL;
    }

    for (i=0; i<MAX_VIDEO_DECODERS; i++) {
        videoDecoder[i] = NULL;
        simpleVideoDecoder[i] = NULL;
    }

    for (i=0; i<MAX_ENCODERS; i++) {
        simpleEncoder[i] = NULL;
    }

    get_initial_output_formats_from_property(&initial_hd_format, &initial_sd_format);

    gfx2D = NEXUS_Graphics2D_Open(NEXUS_ANY_ID,NULL);
        
    BKNI_CreateEvent(&gfxDone);
    NEXUS_Graphics2D_GetSettings(gfx2D, &gfxSettings);
    gfxSettings.checkpointCallback.callback = complete;
    gfxSettings.checkpointCallback.context = gfxDone;
    NEXUS_Graphics2D_SetSettings(gfx2D, &gfxSettings);
    if (platformInitAudio() != 0) {
        LOGE("%s: Could not initialise platform audio!!!", __PRETTY_FUNCTION__);
        BDBG_ASSERT(false);
    }
    else {
        if (platformInitVideo() != 0) {
            LOGE("%s: Could not initialise platform video!!!", __PRETTY_FUNCTION__);
            BDBG_ASSERT(false);
        }
        else {
            if (platformInitHdmiOutputs() != 0) {
                LOGE("%s: Could not initialise HDMI output(s)!!!", __PRETTY_FUNCTION__);
                BDBG_ASSERT(false);
            }
            else {
                if (platformInitSurfaceCompositor() != 0) {
                    LOGE("%s: Could not initialise surface compositor!!!", __PRETTY_FUNCTION__);
                    BDBG_ASSERT(false);
                }
            }
        }
    }

#if NEXUS_HAS_CEC
    i = NEXUS_NUM_CEC;
    while (i--) {
        if (isCecEnabled(i)) {
            mCecServiceManager[i] = CecServiceManager::instantiate(this, i);

            if (mCecServiceManager[i] != NULL) {
                if (mCecServiceManager[i]->platformInit() != OK) {
                    LOGE("%s: ERROR initialising CecServiceManager platform for CEC%d!", __PRETTY_FUNCTION__, i);
                    mCecServiceManager[i] = NULL;
                }
            }
            else {
                LOGE("%s: ERROR instantiating CecServiceManager for CEC%d!", __PRETTY_FUNCTION__, i);
            }
        }
    }
#endif

    // special handling for 1080p HD display
    if (property_get("ro.hd_output_format", value, NULL)) {
        if (strncmp((char *) value, "1080p",5)==0) {
            LOGW("Set HD output format to 1080p...");
            NEXUS_DisplaySettings settings;
            getDisplaySettings(HD_DISPLAY, &settings);
            settings.format = NEXUS_VideoFormat_e1080p60hz;
            setDisplaySettings(HD_DISPLAY, &settings);
        }
    }
}

void NexusService::platformUninit()
{
    platformUninitHdmiOutputs();

#if NEXUS_HAS_CEC
    for (unsigned i = 0; i < NEXUS_NUM_CEC; i++) {
        if (mCecServiceManager[i] != NULL) {
            mCecServiceManager[i]->platformUninit();
            mCecServiceManager[i] = NULL;
        }
    }
#endif

#if ANDROID_ENABLE_HDMI_HDCP
    NEXUS_PlatformConfiguration platformConfig;

    NEXUS_Platform_GetConfiguration(&platformConfig);

    for (int i=0; i < NEXUS_NUM_HDMI_OUTPUTS; i++) {
        NEXUS_HdmiOutputSettings hdmiSettings;

        NEXUS_HdmiOutput_GetSettings(platformConfig.outputs.hdmi[i], &hdmiSettings);
        hdmiSettings.hotplugCallback.callback = NULL;
        hdmiSettings.hotplugCallback.context = NULL;
        hdmiSettings.hotplugCallback.param = 0;
        NEXUS_HdmiOutput_SetSettings(platformConfig.outputs.hdmi[i], &hdmiSettings);
    }
#endif

    if (gfx2D) {
        NEXUS_Graphics2D_Close(gfx2D);
        gfx2D = NULL;
    }
}

void NexusService::instantiate() {
    NexusService *nexusservice = new NexusService();

    nexusservice->platformInit();

    defaultServiceManager()->addService(
                INexusService::descriptor, nexusservice);
}

NexusService::NexusService() : powerState(ePowerState_S0)
{
    server = new NexusServerContext();

    if (server == NULL) {
        LOGE("%s: FATAL: Could not allocate memory for NexusServerContext!", __PRETTY_FUNCTION__);
        BDBG_ASSERT(server != NULL);
    }
    LOGI("NexusService Created");
    surface_compositor = NULL;
    surfaceclient = NULL;
    gfx2D = NULL;
}

NexusService::~NexusService()
{
    LOGI("NexusService Destroyed");

    platformUninit();

    delete server;
    server = NULL;
}

NEXUS_ClientHandle NexusService::clientJoin(const b_refsw_client_client_name *pClientName, NEXUS_ClientAuthenticationSettings *pClientAuthenticationSettings)
{
    NEXUS_ClientHandle nexusClient;

    Mutex::Autolock autoLock(server->mLock);

    nexusClient = NULL;

#ifdef MAX_CLIENTS
    if (server->mJoinRefCount < MAX_CLIENTS) {
#else
    if (true) {
#endif
        pClientAuthenticationSettings->certificate.length =
            BKNI_Snprintf((char *)pClientAuthenticationSettings->certificate.data,
                          sizeof(pClientAuthenticationSettings->certificate.data),
                          "%u,%#x%#x,%s", server->lastId.client, lrand48(), lrand48(), pClientName->string);

        if (pClientAuthenticationSettings->certificate.length >= sizeof(pClientAuthenticationSettings->certificate.data)-1) {
            LOGE("%s: Invalid certificate length %d for client \"%s\"!!!", __PRETTY_FUNCTION__, pClientAuthenticationSettings->certificate.length, pClientName->string);
            (void)BERR_TRACE(BERR_NOT_SUPPORTED);
        }
        else {
            NEXUS_PlatformConfiguration platformConfig;
            NEXUS_ClientSettings        clientSettings;

            LOGI("client %s registering as '%s'", pClientName->string, (char *)pClientAuthenticationSettings->certificate.data);

            NEXUS_Platform_GetDefaultClientSettings(&clientSettings);
            clientSettings.authentication.certificate = pClientAuthenticationSettings->certificate;
            NEXUS_Platform_GetConfiguration(&platformConfig);
            clientSettings.configuration.heap[0] = NEXUS_Platform_GetFramebufferHeap(NEXUS_OFFSCREEN_SURFACE);
            clientSettings.configuration.heap[1] = platformConfig.heap[NEXUS_MAIN_HEAP_IDX];
#ifdef NEXUS_VIDEO_SECURE_HEAP
            clientSettings.configuration.heap[2] = platformConfig.heap[NEXUS_VIDEO_SECURE_HEAP];
#endif
#ifdef NEXUS_SECONDARY_OFFSCREEN_SURFACE
            clientSettings.configuration.heap[3] = NEXUS_Platform_GetFramebufferHeap(NEXUS_SECONDARY_OFFSCREEN_SURFACE);
            if (clientSettings.configuration.heap[3] == clientSettings.configuration.heap[0]) {
                clientSettings.configuration.heap[3] = NULL;
            }
#endif
            clientSettings.configuration.mode = (NEXUS_ClientMode)ANDROID_CLIENT_SECURITY_MODE;
            nexusClient = NEXUS_Platform_RegisterClient(&clientSettings);
            if (nexusClient) {
                LOGI("%s: Successfully registered client \"%s\".", __PRETTY_FUNCTION__, pClientName->string);
                server->lastId.client++;
                server->mJoinRefCount++;
            }
            else {
                LOGE("%s: Could not register client \"%s\"!!!", __PRETTY_FUNCTION__, pClientName->string);
                (void)BERR_TRACE(BERR_NOT_SUPPORTED);
            }
        }
    }
    else {
        LOGE("%s: FATAL: too many clients already joined!!!", __PRETTY_FUNCTION__);
    }
    return nexusClient;
}

NEXUS_Error NexusService::clientUninit(NEXUS_ClientHandle nexusClient)
{
    NEXUS_Error rc;

    Mutex::Autolock autoLock(server->mLock);

#ifdef MAX_CLIENTS
    if (server->mJoinRefCount > 0) {
#else
    if (true) {
#endif
        server->mJoinRefCount--;

        if (nexusClient == NULL) {
            LOGE("%s: Nexus client handle is NULL!!!", __PRETTY_FUNCTION__);
            rc = NEXUS_INVALID_PARAMETER;
        }
        else {
            NEXUS_Platform_UnregisterClient(nexusClient);
            rc = NEXUS_SUCCESS;
        }
    }
    else {
        LOGE("%s: No clients have joined the service!", __PRETTY_FUNCTION__);
        rc = NEXUS_NOT_INITIALIZED;
    }

    return rc;
}

NexusClientContext * NexusService::createClientContext(const b_refsw_client_client_configuration *config)
{
    NexusClientContext * client;
    NEXUS_ClientSettings clientSettings;
    NEXUS_Error rc;

    NEXUS_PlatformConfiguration platformConfig;

    client = (NexusClientContext *)BKNI_Malloc(sizeof(NexusClientContext));
    if (client==NULL) {
        (void)BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
        return NULL;
    }

    BKNI_Memset(client, 0, sizeof(*client));
    BDBG_OBJECT_SET(client, NexusClientContext);

    client->createConfig = *config;

    BLST_D_INSERT_HEAD(&server->clients, client, link);

    client->ipc.nexusClient = getNexusClient(client);

    // This is used to indicate whether client has requested HDMI input or not...
    if (config->resources.hdmiInput > 0) {
        client->info.hdmiInputId = 1;
    }

    if (powerState != ePowerState_S0) {
        NEXUS_PlatformStandbySettings nexusStandbySettings;

        LOGI("We need to set Nexus Power State S0 first...");
        NEXUS_Platform_GetStandbySettings(&nexusStandbySettings);
        nexusStandbySettings.mode = NEXUS_PlatformStandbyMode_eOn;    
        rc = NEXUS_Platform_SetStandbySettings(&nexusStandbySettings);
        if (rc != NEXUS_SUCCESS) {
            LOGE("Oops we couldn't set Nexus Power State to S0!");
            goto err_client;
        }
        else {
            LOGI("Successfully set Nexus Power State S0");
        }
    }
    LOGI("%s: Exiting with client=%p", __PRETTY_FUNCTION__, (void *)client);
    return client;

err_client:
    /* todo fix cleanup */
    return NULL;
}

void NexusService::destroyClientContext(NexusClientContext * client)
{
    BDBG_OBJECT_ASSERT(client, NexusClientContext);
    if(client->resources.videoSurface) {
        NEXUS_SurfaceCompositor_DestroyClient(client->resources.videoSurface);
        client->resources.videoSurface = NULL;
    }

    if(client->resources.graphicsSurface) {
        NEXUS_SurfaceCompositor_DestroyClient(client->resources.graphicsSurface);
        client->resources.graphicsSurface = NULL;
    }
    if(client->ipc.nexusClient) {
        client->ipc.nexusClient = NULL;
    }
    BLST_D_REMOVE(&server->clients, client, link);
    BDBG_OBJECT_DESTROY(client, NexusClientContext);
    BKNI_Free(client);
}

bool NexusService::addGraphicsWindow(NexusClientContext * client)
{
    char value[PROPERTY_VALUE_MAX];
    bool enable_offset = false;
    int rc;
    int xoff=0, yoff=0;
    unsigned width=0, height=0;
    b_refsw_client_client_configuration *config = &client->createConfig;

    NEXUS_SurfaceCompositorClientSettings *p_client_settings = NULL;

    LOGD("%s[%d]: >>>>>>>>>>>>>>>>>>>>>>>>>> addGraphicsWindow Called Creating NSCClient[IPC] <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<",__PRETTY_FUNCTION__,__LINE__);
    /* See if we need to tweak the graphics to fit on the screen */
    if (property_get("ro.screenresize.x", value, NULL)) {
        xoff = atoi(value);
        if (property_get("ro.screenresize.y", value, NULL)) {
            yoff = atoi(value);
            if (property_get("ro.screenresize.w", value, NULL)) {
                width = atoi(value);
                if (property_get("ro.screenresize.h", value, NULL)) {
                    height = atoi(value);
                    enable_offset = true;
                }
            }
        }
    }

    /* If user has not set gfx window size, read them from HD output's properties */
    if ((config->resources.screen.position.width == 0) && (config->resources.screen.position.height == 0)) {
        NEXUS_VideoFormatInfo fmt_info;
        NEXUS_VideoFormat hd_fmt, sd_fmt;
        
        get_initial_output_formats_from_property(&hd_fmt, NULL);
        NEXUS_VideoFormat_GetInfo(hd_fmt, &fmt_info);

        config->resources.screen.position.width = fmt_info.width;
        config->resources.screen.position.height = fmt_info.height;
    }

    client->resources.graphicsSurface = NEXUS_SurfaceCompositor_CreateClient(surface_compositor, server->lastId.surfaceClientId);
    if (!client->resources.graphicsSurface) {
        (void)BERR_TRACE(BERR_NOT_SUPPORTED);
        goto err_screen;
    }
    // save the surface compositor client
    surfaceclient = client->resources.graphicsSurface;
    
    client->info.surfaceClientId = server->lastId.surfaceClientId;
    p_client_settings = (NEXUS_SurfaceCompositorClientSettings *)BKNI_Malloc(sizeof(NEXUS_SurfaceCompositorClientSettings));
    if (p_client_settings) {
        NEXUS_SurfaceCompositor_GetClientSettings(surface_compositor, client->resources.graphicsSurface, p_client_settings);
        p_client_settings->composition.position = config->resources.screen.position;
        p_client_settings->composition.zorder = client->info.surfaceClientId;
        p_client_settings->composition.virtualDisplay.width = config->resources.screen.position.width;
        p_client_settings->composition.virtualDisplay.height = config->resources.screen.position.height;

        if (enable_offset) {
            LOGD("######### REPOSITIONING REQUIRED %d %d %d %d ###############\n",xoff,yoff,width,height);
            p_client_settings->composition.clipRect.width = p_client_settings->composition.virtualDisplay.width;
            p_client_settings->composition.clipRect.height = p_client_settings->composition.virtualDisplay.height;
            p_client_settings->composition.position.x = xoff;
            p_client_settings->composition.position.y = yoff;
            p_client_settings->composition.position.width = width;
            p_client_settings->composition.position.height = height;
        }

        rc = NEXUS_SurfaceCompositor_SetClientSettings(surface_compositor, client->resources.graphicsSurface, p_client_settings);
        BKNI_Free(p_client_settings);
        if (rc!=NEXUS_SUCCESS) {
            (void)BERR_TRACE(BERR_NOT_SUPPORTED);
            goto err_screen_settings;
        }
        server->lastId.surfaceClientId++;
        return true;
    }

err_screen_settings:
    NEXUS_SurfaceCompositor_DestroyClient(client->resources.graphicsSurface);
err_screen:
    return false;
}

void NexusService::getClientInfo(NexusClientContext * client, b_refsw_client_client_info *info)
{
    BDBG_OBJECT_ASSERT(client, NexusClientContext);
    *info = client->info;
}


void NexusService::getClientComposition(NexusClientContext * client __unused, NEXUS_SurfaceComposition *pComposition)
{
    NEXUS_SurfaceCompositorClientSettings *p_client_settings = NULL;

    p_client_settings = (NEXUS_SurfaceCompositorClientSettings *)BKNI_Malloc(sizeof(NEXUS_SurfaceCompositorClientSettings));
    if (p_client_settings) {
        NEXUS_SurfaceCompositor_GetClientSettings(surface_compositor, surfaceclient, p_client_settings);
        *pComposition = p_client_settings->composition;
        BKNI_Free(p_client_settings);
    }
}

void NexusService::setClientComposition(NexusClientContext * client __unused, NEXUS_SurfaceComposition *pComposition)
{
    NEXUS_SurfaceCompositorClientSettings *p_client_settings = NULL;
    NEXUS_Error rc;

    p_client_settings = (NEXUS_SurfaceCompositorClientSettings *)BKNI_Malloc(sizeof(NEXUS_SurfaceCompositorClientSettings));
    if (p_client_settings) {
        NEXUS_SurfaceCompositor_GetClientSettings(surface_compositor, surfaceclient, p_client_settings);    
        p_client_settings->composition = *pComposition;
        LOGD("%s: setting client composition [%d,%d,%d,%d]",__PRETTY_FUNCTION__, pComposition->position.x,
        pComposition->position.y, pComposition->position.width, pComposition->position.height);
    
        rc = NEXUS_SurfaceCompositor_SetClientSettings(surface_compositor, surfaceclient, p_client_settings);
        if (rc != NEXUS_SUCCESS) {
            LOGE("%s:%d NEXUS_SurfaceCompositor_SetClientSettings() returned error, rc=%d",__PRETTY_FUNCTION__,__LINE__,rc);
        }

        BKNI_Free(p_client_settings);
    }
    return;
}

void NexusService::getVideoWindowSettings(NexusClientContext * client __unused, uint32_t window_id, b_video_window_settings *settings)
{
    NEXUS_VideoWindowSettings nSettings;

    if (window_id >= MAX_VIDEO_WINDOWS_PER_DISPLAY) {
        LOGE("%s: window_id(%d) cannot be >= %d!", __PRETTY_FUNCTION__, window_id, MAX_VIDEO_WINDOWS_PER_DISPLAY);
        return;
    }

    // Always return settings for primary display (HD_DISPLAY) as client code works only on HD_DISPLAY
    if (displayState[HD_DISPLAY].video_window[window_id]) {
        NEXUS_DisplaySettings disp_settings;
        NEXUS_VideoFormatInfo fmt_info;
        
        /* Get actual display resolution to populate virtual display settings... */
        NEXUS_Display_GetSettings(displayState[HD_DISPLAY].display, &disp_settings);
        NEXUS_VideoFormat_GetInfo(disp_settings.format, &fmt_info);
        settings->virtualDisplay.width  = fmt_info.width;
        settings->virtualDisplay.height = fmt_info.height;

        NEXUS_VideoWindow_GetSettings(displayState[HD_DISPLAY].video_window[window_id], &nSettings);
        settings->position      = nSettings.position;
        settings->clipRect      = nSettings.clipRect;
        settings->visible       = nSettings.visible;
        settings->contentMode   = nSettings.contentMode;
        settings->autoMaster    = nSettings.autoMaster;
        settings->zorder        = nSettings.zorder;
    }
    return;
}

void NexusService::setVideoWindowSettings(NexusClientContext * client __unused, uint32_t window_id, b_video_window_settings *settings)
{
    NEXUS_VideoWindowSettings nSettings;

    if (window_id >= MAX_VIDEO_WINDOWS_PER_DISPLAY) {
        LOGE("%s: window_id(%d) cannot be >= %d!", __PRETTY_FUNCTION__, window_id, MAX_VIDEO_WINDOWS_PER_DISPLAY);
        return;
    }

    for (int display_id = HD_DISPLAY; display_id < MAX_NUM_DISPLAYS; display_id++) {
        if (displayState[display_id].video_window[window_id]) {
            NEXUS_VideoWindow_GetSettings(displayState[display_id].video_window[window_id], &nSettings);
            if (display_id == HD_DISPLAY) {
                /* NOTE: virtual display settings are ignored. */
                nSettings.position        = settings->position;
                nSettings.clipRect        = settings->clipRect;
                nSettings.visible         = settings->visible;
                nSettings.contentMode     = settings->contentMode;
                nSettings.autoMaster      = settings->autoMaster;
                nSettings.zorder          = settings->zorder;
            }
            else {                
                // User has passed the settings for HD_DISPLAY, so do the necessary HD to SD translation (wherever applicable) before passing it to nexus
                uint32_t sd_width, sd_height;
                uint32_t hd_width, hd_height;
                NEXUS_VideoWindowSettings hd_win_settings;

                /* settings might be set based on the old output format, we should use current output format and window setting */
                NEXUS_DisplaySettings disp_settings;
                NEXUS_VideoFormatInfo fmt_info;
                
                /* get hd display setting and window settings first */
                NEXUS_Display_GetSettings(displayState[HD_DISPLAY].display, &disp_settings);
                NEXUS_VideoWindow_GetSettings(displayState[HD_DISPLAY].video_window[window_id], &hd_win_settings);
                NEXUS_VideoFormat_GetInfo(disp_settings.format, &fmt_info);
                hd_width = fmt_info.width;
                hd_height = fmt_info.height;

                /* then get sd display setting */
                NEXUS_Display_GetSettings(displayState[display_id].display, &disp_settings);
                NEXUS_VideoFormat_GetInfo(disp_settings.format, &fmt_info); 
                sd_width = fmt_info.width;
                sd_height = fmt_info.height;
                
                nSettings.position.x      = (hd_win_settings.position.x * sd_width) / hd_width;
                nSettings.position.y      = (hd_win_settings.position.y * sd_height) / hd_height;
                nSettings.position.width  = (hd_win_settings.position.width * sd_width) / hd_width;
                nSettings.position.height = (hd_win_settings.position.height * sd_height) / hd_height;
                nSettings.clipRect.x      = (hd_win_settings.clipRect.x * sd_width) / hd_width;
                nSettings.clipRect.y      = (hd_win_settings.clipRect.y * sd_width) / hd_width;
                nSettings.clipRect.width  = (hd_win_settings.clipRect.width * sd_width) / hd_width;
                nSettings.clipRect.height = (hd_win_settings.clipRect.height * sd_width) / hd_width;

                //Below are needed or else aspect ratio changes will not come into effect
                nSettings.visible       = settings->visible;
                nSettings.contentMode   = settings->contentMode;
                nSettings.autoMaster    = settings->autoMaster;
            }

            LOGV ("position.width %d position.height %d %s %d", nSettings.position.width, nSettings.position.height, __PRETTY_FUNCTION__, __LINE__);
            if ((nSettings.position.width < 2) || (nSettings.position.height < 1)) {
              LOGE ("window width %d x height %d is too small", nSettings.position.width, nSettings.position.height);
              // interlaced content min is 2x2
              nSettings.position.width = 2;
              nSettings.position.height = 2;
            }

            NEXUS_VideoWindow_SetSettings(displayState[display_id].video_window[window_id], &nSettings);            
        }
    }//for
    return;
}

void NexusService::getDisplaySettings(uint32_t display_id, NEXUS_DisplaySettings *settings)
{
    if (display_id >= MAX_NUM_DISPLAYS) {
        LOGE("display_id(%d) cannot be more than 1!",display_id);
        return;
    }
    if (displayState[display_id].display) {
        NEXUS_Display_GetSettings(displayState[display_id].display, settings);
    }
    else {
        LOGE("displayHandle[%d] is NULL",display_id);
    }
    
    return;
}

void NexusService::setDisplayState(bool enable)
{
    NEXUS_SurfaceCompositorSettings *p_surface_compositor_settings = NULL;
    int rc;
    
    p_surface_compositor_settings = (NEXUS_SurfaceCompositorSettings *)BKNI_Malloc(sizeof(NEXUS_SurfaceCompositorSettings));
    if (NULL == p_surface_compositor_settings) {
        while(1) LOGE("%s:%d BKNI_Malloc failed",__PRETTY_FUNCTION__,__LINE__);
        return;
    }
    
    NEXUS_SurfaceCompositor_GetSettings(surface_compositor, p_surface_compositor_settings);

    if (!enable) {
        BKNI_ResetEvent(inactiveEvent);
        
        /* disable surface compositor */        
        p_surface_compositor_settings->enabled = false;
        NEXUS_SurfaceCompositor_SetSettings(surface_compositor, p_surface_compositor_settings);
        
        rc = BKNI_WaitForEvent(inactiveEvent, 5000);        
        if (rc) {   
            LOGE("Did not receive NSC inactive event!");
            if(p_surface_compositor_settings) 
                BKNI_Free(p_surface_compositor_settings);
            return;
        }
    }
    else {
        /* reenable surface compositor, framebuffer size should be changed */
        p_surface_compositor_settings->enabled = true;
        NEXUS_SurfaceCompositor_SetSettings(surface_compositor, p_surface_compositor_settings);
    }
    
    if (p_surface_compositor_settings) {
        BKNI_Free(p_surface_compositor_settings);
    }
    return;
}

void NexusService::setDisplaySettings(uint32_t display_id, NEXUS_DisplaySettings *settings)
{
    if (display_id >= MAX_NUM_DISPLAYS) {
        LOGE("display_id(%d) cannot be more than 1!",display_id);
        return;
    }

    if (displayState[display_id].display) {        
        /* set display setting, now we only support format change. sd display format should be changed based on hd display format */        
        NEXUS_SurfaceCompositorSettings *p_surface_compositor_settings = NULL;
        NEXUS_DisplaySettings disp_settings;
        NEXUS_VideoFormatInfo formatInfo;
        int rc;
        
        NEXUS_Display_GetSettings(displayState[display_id].display, &disp_settings);
        if (disp_settings.format == settings->format) {  
            LOGE("display_id(%d) no format change ",display_id);
            return;
        }

        p_surface_compositor_settings = (NEXUS_SurfaceCompositorSettings *)BKNI_Malloc(sizeof(NEXUS_SurfaceCompositorSettings));
        if (NULL == p_surface_compositor_settings) {
            while(1) LOGE("%s:%d BKNI_Malloc failed",__PRETTY_FUNCTION__,__LINE__);
            return;
        }

        BKNI_ResetEvent(inactiveEvent);
        
        /* disable surface compositor */        
        NEXUS_SurfaceCompositor_GetSettings(surface_compositor, p_surface_compositor_settings);
        p_surface_compositor_settings->enabled = false;
        NEXUS_SurfaceCompositor_SetSettings(surface_compositor, p_surface_compositor_settings);
        
        rc = BKNI_WaitForEvent(inactiveEvent, 5000);        
        if (rc) {   
            LOGE("Did not receive NSC inactive event - not changing the display resolution for display=%d",display_id);
            if (p_surface_compositor_settings) {
                BKNI_Free(p_surface_compositor_settings);
            }
            return;
        }
        
        NEXUS_Display_SetSettings(displayState[display_id].display, settings);

        NEXUS_VideoFormat_GetInfo(settings->format, &formatInfo);

        LOGD("--- display_id(%d) setDisplaySettings %d, w %d, h %d",display_id, settings->format, formatInfo.width, formatInfo.height);
        /* reenable surface compositor, framebuffer size should be changed */
        NEXUS_SurfaceCompositor_GetSettings(surface_compositor, p_surface_compositor_settings);
        p_surface_compositor_settings->enabled = true;
        p_surface_compositor_settings->display[display_id].framebuffer.width = formatInfo.width;
        p_surface_compositor_settings->display[display_id].framebuffer.height = formatInfo.height;

        /* NSC settings when transitioning to/from 3D display format */
        if (HD_DISPLAY == display_id) {    
            if ((NEXUS_VideoFormat_e720p_3DOU_AS == settings->format) || (NEXUS_VideoFormat_e1080p24hz_3DOU_AS == settings->format)) {
                // when transitioning to 3D display format, following are needed or else vertical display resolution will be half
                p_surface_compositor_settings->display[HD_DISPLAY].display3DSettings.overrideOrientation = true;
                p_surface_compositor_settings->display[HD_DISPLAY].display3DSettings.orientation = NEXUS_VideoOrientation_e2D;
            }
            else {
                // when transitioning from 3D display format, disable overrideOrientation
                p_surface_compositor_settings->display[HD_DISPLAY].display3DSettings.overrideOrientation = false;
                p_surface_compositor_settings->display[HD_DISPLAY].display3DSettings.orientation = NEXUS_VideoOrientation_e2D;
            }
        }
        
        if (display_id == SD_DISPLAY) {/* no scaler in gfd1, we should use the whole sd framebuffer */
            p_surface_compositor_settings->display[display_id].graphicsSettings.clip.width = 0;
        }
        
        NEXUS_SurfaceCompositor_SetSettings(surface_compositor, p_surface_compositor_settings);
        
        if (p_surface_compositor_settings) {
            BKNI_Free(p_surface_compositor_settings);
        }
    }
    else {
        LOGE("displayHandle[%d] is NULL",display_id);        
    }
    return;
}

void NexusService::getPictureCtrlCommonSettings(uint32_t window_id, NEXUS_PictureCtrlCommonSettings *settings)
{
    if (window_id >= MAX_VIDEO_WINDOWS_PER_DISPLAY) {
        LOGE("%s: window_id(%d) cannot be >= %d!", __PRETTY_FUNCTION__, window_id, MAX_VIDEO_WINDOWS_PER_DISPLAY);
        return;
    }

    // Always return settings for primary display (HD_DISPLAY) as client code works only on HD_DISPLAY
    if (displayState[HD_DISPLAY].video_window[window_id]) {
        NEXUS_PictureCtrl_GetCommonSettings(displayState[HD_DISPLAY].video_window[window_id],settings);
    }
    return;
}

void NexusService::setPictureCtrlCommonSettings(uint32_t window_id, NEXUS_PictureCtrlCommonSettings *settings)
{
    if (window_id >= MAX_VIDEO_WINDOWS_PER_DISPLAY) {
        LOGE("%s: window_id(%d) cannot be >= %d!", __PRETTY_FUNCTION__, window_id, MAX_VIDEO_WINDOWS_PER_DISPLAY);
        return;
    }

    for (int display_id = HD_DISPLAY; display_id < MAX_NUM_DISPLAYS; display_id++) {
        if (displayState[display_id].video_window[window_id]) {
            NEXUS_PictureCtrl_SetCommonSettings(displayState[display_id].video_window[window_id],settings);
        }
    }
    return;
}

void NexusService::getGraphicsColorSettings(uint32_t display_id, NEXUS_GraphicsColorSettings *settings)
{
    if (display_id >= MAX_NUM_DISPLAYS) {
        LOGE("%s: display_id(%d) cannot be >= %d!", __PRETTY_FUNCTION__, display_id, MAX_NUM_DISPLAYS);
        return;
    }

    if (displayState[display_id].display) {
        NEXUS_Display_GetGraphicsColorSettings(displayState[display_id].display, settings);
    }
    else {
        LOGE("%s: displayHandle[%d] is NULL!", __PRETTY_FUNCTION__, display_id);        
    }
    return;
}

void NexusService::setGraphicsColorSettings(uint32_t display_id, NEXUS_GraphicsColorSettings *settings)
{
    if (display_id >= MAX_NUM_DISPLAYS) {
        LOGE("%s: display_id(%d) cannot be >= %d!", __PRETTY_FUNCTION__, display_id, MAX_NUM_DISPLAYS);
        return;
    }

    if (displayState[display_id].display) {        
        NEXUS_Display_SetGraphicsColorSettings(displayState[display_id].display, settings);        
    }
    else {
        LOGE("%s: displayHandle[%d] is NULL!", __PRETTY_FUNCTION__, display_id);        
    }
    return;
}

void NexusService::setDisplayOutputs(int display)
{
    NEXUS_PlatformConfiguration platformConfig;
        
    NEXUS_Platform_GetConfiguration(&platformConfig);
    LOGI("NexusService::setDisplayOutputs %d",display);
    
    if (display) {
#if NEXUS_NUM_COMPONENT_OUTPUTS
        NEXUS_Display_AddOutput(displayState[HD_DISPLAY].display, NEXUS_ComponentOutput_GetConnector(platformConfig.outputs.component[0]));
#endif

#if NEXUS_HAS_HDMI_OUTPUT && NEXUS_NUM_HDMI_OUTPUTS
        /* Add HDMI Output to the HD-Display */
        NEXUS_Display_AddOutput(displayState[HD_DISPLAY].display, NEXUS_HdmiOutput_GetVideoConnector(platformConfig.outputs.hdmi[0]));
#endif

#if NEXUS_NUM_COMPOSITE_OUTPUTS
        if (MAX_NUM_DISPLAYS > 1) {
            /* Add Composite Output to the SD-Display */
            NEXUS_Display_AddOutput(displayState[SD_DISPLAY].display, NEXUS_CompositeOutput_GetConnector(platformConfig.outputs.composite[0]));        
        }
#endif
    } 
    else {
        NEXUS_Display_RemoveAllOutputs(displayState[HD_DISPLAY].display); 
        
        if (MAX_NUM_DISPLAYS > 1) {
            /* Add Composite Output to the SD-Display */
            NEXUS_Display_RemoveAllOutputs(displayState[SD_DISPLAY].display);        
        }      
    } 
    return;
}

void NexusService::setAudioMute(int mute)
{
    NEXUS_PlatformConfiguration platformConfig;
    NEXUS_AudioOutputSettings settings;
    NEXUS_AudioOutput output;
    NEXUS_Error aud_err;
    int32_t leftVolume;
    int32_t rightVolume;

    NEXUS_Platform_GetConfiguration(&platformConfig);

#if NEXUS_NUM_AUDIO_DACS
    /* DAC out params config */
    output = NEXUS_AudioDac_GetConnector(platformConfig.outputs.audioDacs[0]);
    NEXUS_AudioOutput_GetSettings(output, &settings);
    settings.muted = mute;
    
    /* Set Dac Volume */
    aud_err = NEXUS_AudioOutput_SetSettings(output, &settings);
    BDBG_ASSERT(aud_err==BERR_SUCCESS);
#endif

    /* Spdif out params config */
#if NEXUS_NUM_SPDIF_OUTPUTS 
    output = NEXUS_SpdifOutput_GetConnector(platformConfig.outputs.spdif[0]);
    NEXUS_AudioOutput_GetSettings(output, &settings);
    settings.muted = mute;
    
    /* Set Spdif Volume */
    aud_err = NEXUS_AudioOutput_SetSettings(output, &settings);
    BDBG_ASSERT(aud_err==BERR_SUCCESS);
#endif

    /* Set HDMI volume */
#if NEXUS_HAS_HDMI_OUTPUT && NEXUS_NUM_HDMI_OUTPUTS
    output = NEXUS_HdmiOutput_GetAudioConnector(platformConfig.outputs.hdmi[0]);
    NEXUS_AudioOutput_GetSettings(output, &settings);
    settings.muted = false;
    aud_err = NEXUS_AudioOutput_SetSettings(output, &settings);
    BDBG_ASSERT(aud_err==BERR_SUCCESS);
#endif
}

#define AUDIO_VOLUME_SETTING_MIN (0)
#define AUDIO_VOLUME_SETTING_MAX (99)

/****************************************************
* Volume Table in dB, Mapping as linear attenuation *
****************************************************/
static uint32_t Gemini_VolTable[AUDIO_VOLUME_SETTING_MAX+1] =
{
    0,      9,      17,     26,     35,     
    45,     54,     63,     72,     82,
    92,     101,    111,    121,    131,
    141,    151,    162,    172,    183,
    194,    205,    216,    227,    239,
    250,    262,    273,    285,    297,
    310,    322,    335,    348,    361,
    374,    388,    401,    415,    429,
    444,    458,    473,    488,    504,
    519,    535,    551,    568,    585,
    602,    620,    638,    656,    674,
    694,    713,    733,    754,    774,
    796,    818,    840,    864,    887,
    912,    937,    963,    990,    1017,
    1046,   1075,   1106,   1137,   1170,   
    1204,   1240,   1277,   1315,   1356,
    1398,   1442,   1489,   1539,   1592,   
    1648,   1708,   1772,   1842,   1917,
    2000,   2092,   2194,   2310,   2444,
    2602,   2796,   3046,   3398,   9000    
};

void NexusService::setAudioVolume(float left, float right)
{
    int32_t leftVolume;
    int32_t rightVolume;

    LOGV("AudioStreamOutNEXUS %s: at %d left=%f right=%f\n",__PRETTY_FUNCTION__,__LINE__,left,right);
    leftVolume = left*AUDIO_VOLUME_SETTING_MAX;
    rightVolume = right*AUDIO_VOLUME_SETTING_MAX;

    /* Check for boundary */ 
    if (leftVolume > AUDIO_VOLUME_SETTING_MAX)
        leftVolume = AUDIO_VOLUME_SETTING_MAX;
    if (leftVolume < AUDIO_VOLUME_SETTING_MIN)
        leftVolume = AUDIO_VOLUME_SETTING_MIN;
    if (rightVolume > AUDIO_VOLUME_SETTING_MAX)
        rightVolume = AUDIO_VOLUME_SETTING_MAX;
    if (rightVolume < AUDIO_VOLUME_SETTING_MIN)
        rightVolume = AUDIO_VOLUME_SETTING_MIN;

    NEXUS_PlatformConfiguration platformConfig;
    NEXUS_AudioOutputSettings settings;
    NEXUS_AudioOutput output;
    NEXUS_Error aud_err;

    NEXUS_Platform_GetConfiguration(&platformConfig);

#if NEXUS_NUM_AUDIO_DACS
    /* DAC out params config */
    output = NEXUS_AudioDac_GetConnector(platformConfig.outputs.audioDacs[0]);
    NEXUS_AudioOutput_GetSettings(output, &settings);
    settings.volumeType = NEXUS_AudioVolumeType_eDecibel;
    settings.muted = false;
    settings.leftVolume = -Gemini_VolTable[AUDIO_VOLUME_SETTING_MAX-leftVolume];
    settings.rightVolume = -Gemini_VolTable[AUDIO_VOLUME_SETTING_MAX-rightVolume];

    /* Set Dac Volume */
    aud_err = NEXUS_AudioOutput_SetSettings(output, &settings);
    BDBG_ASSERT(aud_err==BERR_SUCCESS);
#endif

    /* Spdif out params config */
#if NEXUS_NUM_SPDIF_OUTPUTS 
    output = NEXUS_SpdifOutput_GetConnector(platformConfig.outputs.spdif[0]);
    NEXUS_AudioOutput_GetSettings(output, &settings);
    settings.volumeType = NEXUS_AudioVolumeType_eDecibel;
    settings.muted = false;
    settings.leftVolume = -Gemini_VolTable[AUDIO_VOLUME_SETTING_MAX-leftVolume];
    settings.rightVolume = -Gemini_VolTable[AUDIO_VOLUME_SETTING_MAX-rightVolume];

    /* Set Spdif Volume */
    aud_err = NEXUS_AudioOutput_SetSettings(output, &settings);
    BDBG_ASSERT(aud_err==BERR_SUCCESS);
#endif

    /* Set HDMI volume */
#if NEXUS_HAS_HDMI_OUTPUT && NEXUS_NUM_HDMI_OUTPUTS
    output = NEXUS_HdmiOutput_GetAudioConnector(platformConfig.outputs.hdmi[0]);
    NEXUS_AudioOutput_GetSettings(output, &settings);
    settings.volumeType = NEXUS_AudioVolumeType_eDecibel;
    settings.muted = false;
    settings.leftVolume = -Gemini_VolTable[AUDIO_VOLUME_SETTING_MAX-leftVolume];
    settings.rightVolume = -Gemini_VolTable[AUDIO_VOLUME_SETTING_MAX-rightVolume];
    
    aud_err = NEXUS_AudioOutput_SetSettings(output, &settings);
    BDBG_ASSERT(aud_err==BERR_SUCCESS);
#endif
}


#if NEXUS_HAS_HDMI_INPUT

static uint8_t SampleEDID[] = 
{
    0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x08, 0x6D, 0x74, 0x22, 0x05, 0x01, 0x11, 0x20,
    0x00, 0x14, 0x01, 0x03, 0x80, 0x00, 0x00, 0x78, 0x0A, 0xDA, 0xFF, 0xA3, 0x58, 0x4A, 0xA2, 0x29,
    0x17, 0x49, 0x4B, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
    0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x02, 0x3A, 0x80, 0x18, 0x71, 0x38, 0x2D, 0x40, 0x58, 0x2C,
    0x45, 0x00, 0xBA, 0x88, 0x21, 0x00, 0x00, 0x1E, 0x01, 0x1D, 0x80, 0x18, 0x71, 0x1C, 0x16, 0x20,
    0x58, 0x2C, 0x25, 0x00, 0xBA, 0x88, 0x21, 0x00, 0x00, 0x9E, 0x00, 0x00, 0x00, 0xFC, 0x00, 0x42,
    0x43, 0x4D, 0x37, 0x34, 0x32, 0x32, 0x2F, 0x37, 0x34, 0x32, 0x35, 0x0A, 0x00, 0x00, 0x00, 0xFD,
    0x00, 0x17, 0x3D, 0x0F, 0x44, 0x0F, 0x00, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x01, 0x89,

    0x02, 0x03, 0x3C, 0x71, 0x7F, 0x03, 0x0C, 0x00, 0x40, 0x00, 0xB8, 0x2D, 0x2F, 0x80, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0xE3, 0x05, 0x1F, 0x01, 0x49, 0x90, 0x05, 0x20, 0x04, 0x03, 0x02, 0x07,
    0x06, 0x01, 0x29, 0x09, 0x07, 0x01, 0x11, 0x07, 0x00, 0x15, 0x07, 0x00, 0x01, 0x1D, 0x00, 0x72,
    0x51, 0xD0, 0x1E, 0x20, 0x6E, 0x28, 0x55, 0x00, 0xBA, 0x88, 0x21, 0x00, 0x00, 0x1E, 0x8C, 0x0A,
    0xD0, 0x8A, 0x20, 0xE0, 0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0xBA, 0x88, 0x21, 0x00, 0x00, 0x18,
    0x8C, 0x0A, 0xD0, 0x8A, 0x20, 0xE0, 0x2D, 0x10, 0x10, 0x3E, 0x96, 0x00, 0x0B, 0x88, 0x21, 0x00,
    0x00, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x9D
};

static void source_changed(void *context, int param)
{
    BSTD_UNUSED(context);
    BSTD_UNUSED(param);

    LOGV("source changed\n");
}

static void avmute_changed(void *context, int param)
{
    NEXUS_HdmiInputHandle hdmiInput;
    NEXUS_HdmiInputStatus hdmiInputStatus ;
    BSTD_UNUSED(param);

    hdmiInput = (NEXUS_HdmiInputHandle) context ;
    NEXUS_HdmiInput_GetStatus(hdmiInput, &hdmiInputStatus) ;

    if (!hdmiInputStatus.validHdmiStatus) {
        LOGV("avmute_changed callback: Unable to get hdmiInput status\n") ;
    }
    else {
        LOGV("avmute_changed callback: %s\n", 
            hdmiInputStatus.avMute ? "Set_AvMute" : "Clear_AvMute") ;
    }
}
#endif // NEXUS_HAS_HDMI_INPUT

bool NexusService::connectHdmiInput(NexusClientContext * client __unused, b_refsw_client_connect_resource_settings *pConnectSettings __unused)
{
    NEXUS_Error rc = NEXUS_SUCCESS;
#if NEXUS_HAS_HDMI_INPUT && NEXUS_HAS_HDMI_OUTPUT && ANDROID_SUPPORTS_HDMI_LEGACY
    unsigned timeout = 4;
    unsigned hdmiInputIndex = 0;

    NEXUS_PlatformConfiguration platformConfig;
    NEXUS_HdmiInputSettings hdmiInputSettings;
    NEXUS_HdmiOutputStatus hdmiOutputStatus;
    NEXUS_HdmiOutputHandle hdmiOutput;
    NEXUS_AudioOutput hdmiAudioOutput;

    NEXUS_HdmiInput_GetDefaultSettings(&hdmiInputSettings);
    hdmiInputSettings.timebase = NEXUS_Timebase_e0;
    hdmiInputSettings.sourceChanged.callback = source_changed;
    
    /* set hpdDisconnected to true if a HDMI switch is in front of the Broadcom HDMI Rx.  
         -- The NEXUS_HdmiInput_ConfigureAfterHotPlug should be called to inform the hw of 
         -- the current state,  the Broadcom SV reference boards have no switch so 
         -- the value should always be false 
         */
    hdmiInputSettings.frontend.hpdDisconnected = false ;
    
    /* use NEXUS_HdmiInput_OpenWithEdid ()
          if EDID PROM (U1304 and U1305) is NOT installed; 
            reference boards usually have the PROMs installed.
            this example assumes Port1 EDID has been removed 
        */

    /* all HDMI Tx/Rx combo chips have EDID RAM */
    hdmiInputSettings.useInternalEdid = true ;

    NEXUS_Platform_GetConfiguration(&platformConfig);

    hdmiOutput = platformConfig.outputs.hdmi[0];

    do {
        /* check for connected downstream device */
        rc = NEXUS_HdmiOutput_GetStatus(hdmiOutput, &hdmiOutputStatus);
        if (rc) BERR_TRACE(rc);
        if ( !hdmiOutputStatus.connected ) {
            LOGW("Waiting for HDMI Tx Device");
            BKNI_Sleep(250);
        }
        else {
            break;
        }
    } while (timeout--);

    if (hdmiOutputStatus.connected) {
        NEXUS_HdmiOutputBasicEdidData hdmiOutputBasicEdidData;
        unsigned char *attachedRxEdid;
        NEXUS_HdmiOutputEdidBlock edidBlock;
        unsigned i, j;

        /* Get EDID of attached receiver*/
        NEXUS_HdmiOutput_GetBasicEdidData(hdmiOutput, &hdmiOutputBasicEdidData);

        /* allocate space to hold the EDID blocks */
        attachedRxEdid = (unsigned char*) BKNI_Malloc((hdmiOutputBasicEdidData.extensions+1)* sizeof(edidBlock.data));
        for (i=0; i<= hdmiOutputBasicEdidData.extensions; i++) {
            rc = NEXUS_HdmiOutput_GetEdidBlock(hdmiOutput, i, &edidBlock);
            if (rc) {
                LOGE("Error retrieve EDID from attached receiver");
            }

            for (j=0; j < sizeof(edidBlock.data); j++) {
                attachedRxEdid[i*sizeof(edidBlock.data)+j] = edidBlock.data[j];
            }
        }
        
        /* Load hdmiInput EDID RAM with the EDID from the Rx attached to the hdmiOutput (Tx) . */
        client->resources.hdmiInput.handle = NEXUS_HdmiInput_OpenWithEdid(hdmiInputIndex, &hdmiInputSettings, 
            attachedRxEdid, (uint16_t) (sizeof(NEXUS_HdmiOutputEdidBlock) * (hdmiOutputBasicEdidData.extensions+1)));
        LOGD("Use Edid from attached HDMI Rx device");

        /* release memory resources */
        BKNI_Free(attachedRxEdid);
    }
    else {
        client->resources.hdmiInput.handle = NEXUS_HdmiInput_OpenWithEdid(hdmiInputIndex, &hdmiInputSettings, 
            &SampleEDID[0], (uint16_t) sizeof(SampleEDID));
        LOGD("Use Edid from hardcode BCM sample");
    }

    if (client->resources.hdmiInput.handle == NULL) {
        LOGE("%s: Can't get hdmi input!", __PRETTY_FUNCTION__);
        goto err_hdmi_input;
    }
    else {
        client->resources.hdmiInput.connected = true;

        NEXUS_HdmiInput_GetSettings(client->resources.hdmiInput.handle, &hdmiInputSettings) ;
        hdmiInputSettings.avMuteChanged.callback = avmute_changed;
        hdmiInputSettings.avMuteChanged.context = client->resources.hdmiInput.handle;
        NEXUS_HdmiInput_SetSettings(client->resources.hdmiInput.handle, &hdmiInputSettings) ;
        
#if NEXUS_NUM_AUDIO_INPUT_CAPTURES
        client->resources.hdmiInput.captureInput = NEXUS_AudioInputCapture_Open(0, NULL);
        if (client->resources.hdmiInput.captureInput == NULL) {
            LOGE("%s: Can't get audio input capture!", __PRETTY_FUNCTION__);
            goto err_hdmi_input;
        }
        else {
            NEXUS_AudioInputCaptureStartSettings captureInputStartSettings;

            NEXUS_AudioInputCapture_GetDefaultStartSettings(&captureInputStartSettings);
            captureInputStartSettings.input = NEXUS_HdmiInput_GetAudioConnector(client->resources.hdmiInput.handle);

            NEXUS_AudioInputCapture_Start(client->resources.hdmiInput.captureInput, &captureInputStartSettings);

            /* Shutdown audio decoders/playback channels as they are not required for HDMI audio playback
               and result in issues when the Audio Mixer is re-connected to the HDMI output later on.
             */
            setAudioState(false);

            hdmiAudioOutput = NEXUS_HdmiOutput_GetAudioConnector(hdmiOutput);

            rc = NEXUS_AudioOutput_RemoveAllInputs(hdmiAudioOutput);
            if (rc != NEXUS_SUCCESS) {
                LOGE("%s: Could not remove all inputs from HDMI Audio output!", __PRETTY_FUNCTION__);
                goto err_hdmi_input;
            }
            else {
                rc = NEXUS_AudioOutput_AddInput(hdmiAudioOutput, NEXUS_AudioInputCapture_GetConnector(client->resources.hdmiInput.captureInput));
                if (rc != NEXUS_SUCCESS) {
                    LOGE("%s: Could not add audio input capture to HDMI audio output!", __PRETTY_FUNCTION__);
                    goto err_hdmi_input;
                }
            }
        }
#endif
        if (rc == NEXUS_SUCCESS) {
            NEXUS_SimpleVideoDecoderServerSettings settings;
            unsigned window_id = pConnectSettings->hdmiInput.windowId;

            // Save window id for disconnectHdmiInput()
            client->resources.hdmiInput.windowId = window_id;

            // Remove video window from simpledecoder, so that we can add hdmiIn
            // There is 1-1 mapping between simpleVideoDecoder and videoWindow
            NEXUS_SimpleVideoDecoder_GetServerSettings(simpleVideoDecoder[window_id], &settings);
            settings.window[window_id] = NULL;
            rc = NEXUS_SimpleVideoDecoder_SetServerSettings(simpleVideoDecoder[window_id], &settings);
            if (rc != NEXUS_SUCCESS) {
                LOGE("%s: Could not set simple video decoder server settings for video window %d!", __PRETTY_FUNCTION__, window_id);
                goto err_hdmi_input;
            }
            else {
                // Add Hdmi-In to the video window        
                for(int display_id = HD_DISPLAY; display_id < MAX_NUM_DISPLAYS; display_id++) {
                    rc = NEXUS_VideoWindow_AddInput(displayState[display_id].video_window[window_id],
                         NEXUS_HdmiInput_GetVideoConnector(client->resources.hdmiInput.handle));

                    if (rc != NEXUS_SUCCESS) {
                        LOGE("%s: Could not add HDMI input to video window %d of display %d!", __PRETTY_FUNCTION__, window_id, display_id);
                        goto err_hdmi_input;
                    }
                }
            }
        }
    }
#endif
    return (rc == NEXUS_SUCCESS);

#if NEXUS_HAS_HDMI_INPUT && NEXUS_HAS_HDMI_OUTPUT && ANDROID_SUPPORTS_HDMI_LEGACY
err_hdmi_input:
#if NEXUS_NUM_AUDIO_INPUT_CAPTURES
    if (client->resources.hdmiInput.captureInput != NULL) {
        NEXUS_AudioInput_Shutdown(NEXUS_AudioInputCapture_GetConnector(client->resources.hdmiInput.captureInput));
        NEXUS_AudioInputCapture_Close(client->resources.hdmiInput.captureInput);
        client->resources.hdmiInput.captureInput = NULL;
    }
#endif

    if (client->resources.hdmiInput.handle != NULL) {
        NEXUS_VideoInput_Shutdown(NEXUS_HdmiInput_GetVideoConnector(client->resources.hdmiInput.handle));
        NEXUS_AudioInput_Shutdown(NEXUS_HdmiInput_GetAudioConnector(client->resources.hdmiInput.handle));
        NEXUS_HdmiInput_Close(client->resources.hdmiInput.handle);  
        client->resources.hdmiInput.handle = NULL;
    }
    return false;
#endif
}

bool NexusService::disconnectHdmiInput(NexusClientContext * client __unused)
{
    NEXUS_Error rc = NEXUS_SUCCESS;
#if NEXUS_HAS_HDMI_INPUT && NEXUS_HAS_HDMI_OUTPUT && ANDROID_SUPPORTS_HDMI_LEGACY
#if NEXUS_NUM_AUDIO_INPUT_CAPTURES
    NEXUS_PlatformConfiguration platformConfig;
    NEXUS_AudioOutput           hdmiAudioOutput;
#endif

    if (client->resources.hdmiInput.handle) {
        NEXUS_StopCallbacks(client->resources.hdmiInput.handle);

#if NEXUS_NUM_AUDIO_INPUT_CAPTURES
        if (client->resources.hdmiInput.captureInput) {
            NEXUS_AudioInputCapture_Stop(client->resources.hdmiInput.captureInput);
        }

        NEXUS_Platform_GetConfiguration(&platformConfig);
        hdmiAudioOutput = NEXUS_HdmiOutput_GetAudioConnector(platformConfig.outputs.hdmi[0]);

        rc = NEXUS_AudioOutput_RemoveAllInputs(hdmiAudioOutput);
        if (rc != NEXUS_SUCCESS) {
            LOGE("%s: Could not remove all audio inputs from HDMI audio output!", __PRETTY_FUNCTION__);
        }
        else {
            rc = NEXUS_AudioOutput_AddInput(hdmiAudioOutput, NEXUS_AudioMixer_GetConnector(mixer));
            if (rc != NEXUS_SUCCESS) {
                LOGE("%s: Could not add audio mixer to HDMI output!", __PRETTY_FUNCTION__);
            }
            else {
                /* Re-instate the Audio Decoders and playback channels */
                setAudioState(true);
            }
        }
#endif
    }

    if (rc == NEXUS_SUCCESS) {
        NEXUS_SimpleVideoDecoderServerSettings settings;
        unsigned window_id = client->resources.hdmiInput.windowId;

        // Read video window from simpledecoder, so that we can add hdmiIn
        NEXUS_SimpleVideoDecoder_GetServerSettings(simpleVideoDecoder[window_id], &settings);
        
        // Remove all video inputs (this will remove hdmi-input earlier added to the video window)
        // There is 1-1 mapping between simpleVideoDecoder and videoWindow
        for (int display_id = HD_DISPLAY; display_id < MAX_NUM_DISPLAYS; display_id++) {
            NEXUS_VideoWindow_RemoveAllInputs(displayState[display_id].video_window[window_id]);
            settings.window[display_id] = displayState[display_id].video_window[window_id];
        }
        rc = NEXUS_SimpleVideoDecoder_SetServerSettings(simpleVideoDecoder[window_id], &settings);
        if (rc != NEXUS_SUCCESS) {
            LOGE("%s: Could not set simple video decoder server settings for video window %d!", __PRETTY_FUNCTION__, window_id);
        }
    }
    
#if NEXUS_NUM_AUDIO_INPUT_CAPTURES
    if (client->resources.hdmiInput.captureInput) {
        NEXUS_AudioInput_Shutdown(NEXUS_AudioInputCapture_GetConnector(client->resources.hdmiInput.captureInput));
        NEXUS_AudioInputCapture_Close(client->resources.hdmiInput.captureInput);
        client->resources.hdmiInput.captureInput = NULL;
    }
#endif
    if (client->resources.hdmiInput.handle) {
        NEXUS_VideoInput_Shutdown(NEXUS_HdmiInput_GetVideoConnector(client->resources.hdmiInput.handle));
        NEXUS_AudioInput_Shutdown(NEXUS_HdmiInput_GetAudioConnector(client->resources.hdmiInput.handle));
        NEXUS_HdmiInput_Close(client->resources.hdmiInput.handle);  
        client->resources.hdmiInput.handle = NULL;
    }
#endif
    return (rc == NEXUS_SUCCESS);
}

bool NexusService::isCecEnabled(uint32_t cecId __unused)
{
    bool enabled = false;
#if NEXUS_HAS_CEC
    char value[PROPERTY_VALUE_MAX];

    if (property_get("ro.enable_cec", value, NULL) && strcmp(value,"1")==0) {
        enabled = true;
    }
#endif
    return enabled;
}

bool NexusService::setCecLogicalAddress(unsigned cecId, uint8_t addr)
{
    bool success = false;
#if NEXUS_HAS_CEC
    if (mCecServiceManager[cecId] != NULL && mCecServiceManager[cecId]->isPlatformInitialised()) {
        success = mCecServiceManager[cecId]->setLogicalAddress(addr);
    }
#endif
    if (!success) {
        LOGE("%s: Could not set CEC%d logical address to 0x%02x!", __PRETTY_FUNCTION__, cecId, addr);
    }
    return success;
}

bool NexusService::setCecPowerState(unsigned cecId, b_powerState pmState)
{
    bool success = false;
#if NEXUS_HAS_CEC
    if (mCecServiceManager[cecId] != NULL && mCecServiceManager[cecId]->isPlatformInitialised()) {
        success = mCecServiceManager[cecId]->setPowerState(pmState);
    }
#endif
    if (!success) {
        LOGE("%s: Could not set CEC%d power state %d!", __PRETTY_FUNCTION__, cecId, pmState);
    }
    return success;
}

bool NexusService::getCecPowerStatus(uint32_t cecId, uint8_t *pPowerStatus)
{
    bool success = false;
#if NEXUS_HAS_CEC
    if (mCecServiceManager[cecId] != NULL && mCecServiceManager[cecId]->isPlatformInitialised()) {
        success = mCecServiceManager[cecId]->getPowerStatus(pPowerStatus);
    }
#endif
    if (!success) {
        LOGE("%s: Could not get CEC%d TV power status!", __PRETTY_FUNCTION__, cecId);
    }
    return success;
}

bool NexusService::getCecStatus(uint32_t cecId, b_cecStatus *pCecStatus)
{
    bool success = false;
#if NEXUS_HAS_CEC
    if (mCecServiceManager[cecId] != NULL && mCecServiceManager[cecId]->isPlatformInitialised()) {
        success = mCecServiceManager[cecId]->getCecStatus(pCecStatus);
    }
#endif
    if (!success) {
        LOGE("%s: Could not get CEC%d TV status!", __PRETTY_FUNCTION__, cecId);
    }
    return success;
}

bool NexusService::getHdmiOutputStatus(uint32_t portId, b_hdmiOutputStatus *pHdmiOutputStatus)
{
    NEXUS_Error rc = NEXUS_NOT_SUPPORTED;
#if NEXUS_HAS_HDMI_OUTPUT
    if (portId < NEXUS_NUM_HDMI_OUTPUTS) {
        unsigned loops;
        NEXUS_HdmiOutputHandle hdmiOutput;
        NEXUS_PlatformConfiguration platformConfig;
        NEXUS_HdmiOutputStatus status;

        memset(pHdmiOutputStatus, 0, sizeof(*pHdmiOutputStatus));

        NEXUS_Platform_GetConfiguration(&platformConfig);
        hdmiOutput = platformConfig.outputs.hdmi[portId];

        if (hdmiOutput != NULL) {
            for (loops = 0; loops < 4; loops++) {
                LOGV("%s: Waiting for HDMI%d output to be connected...", __PRETTY_FUNCTION__, portId);
                rc = NEXUS_HdmiOutput_GetStatus(hdmiOutput, &status);
                if ((rc == NEXUS_SUCCESS) && status.connected) {
                    break;
                }
                usleep(250 * 1000);
            }
        }
        
        if (rc == NEXUS_SUCCESS) {
            if (status.connected) {
                pHdmiOutputStatus->connected            = status.connected;
                pHdmiOutputStatus->rxPowered            = status.rxPowered;
                pHdmiOutputStatus->hdmiDevice           = status.hdmiDevice;
                pHdmiOutputStatus->videoFormat          = status.videoFormat;
                pHdmiOutputStatus->preferredVideoFormat = status.preferredVideoFormat;
                pHdmiOutputStatus->aspectRatio          = status.aspectRatio;
                pHdmiOutputStatus->colorSpace           = status.colorSpace;
                pHdmiOutputStatus->audioFormat          = status.audioFormat;
                pHdmiOutputStatus->audioSamplingRate    = status.audioSamplingRate;
                pHdmiOutputStatus->audioSamplingSize    = status.audioSamplingSize;
                pHdmiOutputStatus->audioChannelCount    = status.audioChannelCount;
                pHdmiOutputStatus->physicalAddress[0]   = status.physicalAddressA << 4 | status.physicalAddressB;
                pHdmiOutputStatus->physicalAddress[1]   = status.physicalAddressC << 4 | status.physicalAddressD;
            }
        }
        else {
            LOGE("%s: Could not get HDMI%d output status!!!", __PRETTY_FUNCTION__, portId);
        }
    }
    else
#endif
    {
        LOGE("%s: No HDMI%d output on this device!!!", __PRETTY_FUNCTION__, portId);
    }
    return (rc == NEXUS_SUCCESS);
}

bool NexusService::sendCecMessage(unsigned cecId, uint8_t srcAddr, uint8_t destAddr, size_t length, uint8_t *pMessage)
{
    bool success = false;
#if NEXUS_HAS_CEC
    if (mCecServiceManager[cecId] != NULL && mCecServiceManager[cecId]->isPlatformInitialised()) {
        success = (mCecServiceManager[cecId]->sendCecMessage(srcAddr, destAddr, length, pMessage) == OK) ? true : false;
    }
#endif
    if (!success) {
        LOGE("%s: Could not send CEC%d message opcode: 0x%02X!", __PRETTY_FUNCTION__, cecId, *pMessage);
    }
    return success;
}

bool NexusService::setPowerState(b_powerState pmState)
{
    NEXUS_Error rc = NEXUS_SUCCESS;
    NEXUS_PlatformStandbySettings nexusStandbySettings;

    if (pmState != powerState) {
        NEXUS_Platform_GetStandbySettings(&nexusStandbySettings);

        switch (pmState)
        {
            case ePowerState_S0:
            {
                LOGD("%s: About to set power state S0...", __PRETTY_FUNCTION__);
                nexusStandbySettings.mode = NEXUS_PlatformStandbyMode_eOn;    
                rc = NEXUS_Platform_SetStandbySettings(&nexusStandbySettings);
                if (rc == NEXUS_SUCCESS) {
                    setDisplayState(1);
                    setVideoState(1);
                    setAudioState(1);
                }
                break;
            }

            case ePowerState_S1:
            {
                LOGD("%s: About to set power state S1...", __PRETTY_FUNCTION__);
                setDisplayState(0);
                setVideoState(0);
                setAudioState(0);
                nexusStandbySettings.mode = NEXUS_PlatformStandbyMode_eActive;    
                rc = NEXUS_Platform_SetStandbySettings(&nexusStandbySettings);
                break;
            }

            case ePowerState_S2:
            {
                LOGD("%s: About to set power state S2...", __PRETTY_FUNCTION__);
                setDisplayState(0);
                setVideoState(0);
                setAudioState(0);
                nexusStandbySettings.mode = NEXUS_PlatformStandbyMode_ePassive;
                nexusStandbySettings.wakeupSettings.ir = 1;
                nexusStandbySettings.wakeupSettings.uhf = 1;
                nexusStandbySettings.wakeupSettings.transport = 1;
#if NEXUS_HAS_CEC
                if (isCecEnabled(0)) {
                    nexusStandbySettings.wakeupSettings.cec = 1;
                }
#endif
                nexusStandbySettings.wakeupSettings.gpio = 1;
                nexusStandbySettings.wakeupSettings.timeout = 0;
                rc = NEXUS_Platform_SetStandbySettings(&nexusStandbySettings);
                break;
            }

            case ePowerState_S3:
            case ePowerState_S5:
            {
                LOGD("%s: About to set power state S%d...", __PRETTY_FUNCTION__, pmState-ePowerState_S0);
                setDisplayState(0);
                setVideoState(0);
                setAudioState(0);
                nexusStandbySettings.mode = NEXUS_PlatformStandbyMode_eDeepSleep;  
                nexusStandbySettings.wakeupSettings.ir = 1;
                nexusStandbySettings.wakeupSettings.uhf = 1;
#if NEXUS_HAS_CEC
                if (isCecEnabled(0)) {
                    nexusStandbySettings.wakeupSettings.cec = 1;
                }
#endif
                nexusStandbySettings.wakeupSettings.gpio = 1;
                nexusStandbySettings.wakeupSettings.timeout = 0;
                rc = NEXUS_Platform_SetStandbySettings(&nexusStandbySettings);
                break;
            }

            default:
            {
                LOGE("%s: invalid power state %d!", __PRETTY_FUNCTION__, pmState);
                rc = NEXUS_INVALID_PARAMETER;
                break;
            }
        }
    }

    if (rc == NEXUS_SUCCESS) {
        powerState = pmState;
        return true;
    } else {
        LOGE("%s: ERROR setting power state to S%d!", __PRETTY_FUNCTION__, pmState);
        return false;
    }
}

b_powerState NexusService::getPowerState()
{
    return powerState;
}


/************************************************/
/* ADDED CODE TO CAPTURE THE FRAME              */
/************************************************/




//1 - success
//0 - failure
bool NexusService::getFrame(NexusClientContext * client __unused,
                            const uint32_t width,
                            const uint32_t height,
                            const uint32_t surfacePhyAddress,
                            const NEXUS_PixelFormat surfaceFormat,
                            const uint32_t decoderId) 
{
        NEXUS_Error                     rc = NEXUS_SUCCESS;
        NEXUS_SurfaceCreateSettings     createSettings;
        NEXUS_StripedSurfaceHandle      stripedSurface=NULL; 
        NEXUS_SurfaceHandle             dstSurface;
        NEXUS_MemoryStatus              status;
        uint32_t                        actualOffset;
        NEXUS_VideoDecoderHandle        decoder; 

        //ALOGD("%s %d"ENTER ************",__PRETTY_FUNCTION__,__LINE__);

        decoder = videoDecoder[decoderId];
        if (!decoder) {
            LOGE("Failed TO Acquire Decoder Handle To Start Capture ....");
        }
        
        //ALOGD("%s %d"************",__PRETTY_FUNCTION__,__LINE__);
        void * pTemp = NEXUS_OffsetToCachedAddr(surfacePhyAddress);
        memset(pTemp, 0, 100);
        //ALOGD("%s %d"************",__PRETTY_FUNCTION__,__LINE__);

        NEXUS_Surface_GetDefaultCreateSettings(&createSettings);
        createSettings.pixelFormat = surfaceFormat;
        createSettings.width = width;
        createSettings.height = height;
        createSettings.pMemory = (void*) pTemp;   
        dstSurface = NEXUS_Surface_Create(&createSettings);
        if (!dstSurface) {
            while(1) LOGE("Creating Surface Failed!!");
        }

        //ALOGD("%s %d"************",__PRETTY_FUNCTION__,__LINE__);
        unsigned int reTryCnt=0;
        do {
            stripedSurface = NEXUS_VideoDecoder_CreateStripedSurface(decoder);
            if (stripedSurface == NULL) {
                BKNI_Sleep(12);
                reTryCnt++;
            }
        } while((stripedSurface == NULL) && (reTryCnt <  10));

        if ( stripedSurface == NULL ) {
            LOGE("Creating Striped Surface Failed!!");
            NEXUS_Surface_Destroy(dstSurface);
            ALOGD("%s:%d EXITING",__PRETTY_FUNCTION__,__LINE__);
            return false;
        }

        //ALOGD("%s %d"************",__PRETTY_FUNCTION__,__LINE__);
        rc = NEXUS_Graphics2D_DestripeToSurface( gfx2D, stripedSurface, dstSurface, NULL );
        if (rc) {
            while(1) LOGE("%s:De-Stripe To surface Failed\n",__PRETTY_FUNCTION__);
            NEXUS_Surface_Destroy(dstSurface);
            NEXUS_VideoDecoder_DestroyStripedSurface(decoder,stripedSurface);
            ALOGD("%s:%d EXITING",__PRETTY_FUNCTION__,__LINE__);
            return false;
        }

        //ALOGD("%s %d"************",__PRETTY_FUNCTION__,__LINE__);
        // Wait for the De-Stripe to finish....
        //rc = NEXUS_Graphics2D_Checkpoint( gfx2D, NULL );

        do {
            rc = NEXUS_Graphics2D_Checkpoint(gfx2D, NULL);
            if (rc == (NEXUS_Error) NEXUS_GRAPHICS2D_QUEUED) {
                rc = BKNI_WaitForEvent(gfxDone, 1000);
            }
        } while (rc == (NEXUS_Error) NEXUS_GRAPHICS2D_QUEUE_FULL);

        //ALOGD("%s %d"************",__PRETTY_FUNCTION__,__LINE__);
        NEXUS_Surface_Destroy(dstSurface);
        NEXUS_VideoDecoder_DestroyStripedSurface(decoder,stripedSurface);
        //ALOGD("%s %d"EXITING",__PRETTY_FUNCTION__,__LINE__);
        return true;
}

bool NexusService::connectClientResources(NexusClientContext * client, b_refsw_client_connect_resource_settings *pConnectSettings)
{
    bool ok = true;

    if (pConnectSettings->hdmiInput.id != 0) {
        ok = connectHdmiInput(client, pConnectSettings);
    }
    return ok;
}

bool NexusService::disconnectClientResources(NexusClientContext * client)
{
    bool ok = true;

    if (client->resources.hdmiInput.connected) {
        ok = disconnectHdmiInput(client);
        client->resources.hdmiInput.connected = false;
    }
    return ok;
}

status_t NexusService::setHdmiCecMessageEventListener(uint32_t cecId, const sp<INexusHdmiCecMessageEventListener> &listener)
{
    status_t status = INVALID_OPERATION;
    ALOGV("%s: CEC%d listener=%p", __PRETTY_FUNCTION__, cecId, listener.get());

#if NEXUS_HAS_CEC
    if (cecId < NEXUS_NUM_CEC) {
        if (mCecServiceManager[cecId] != NULL) {
            status = mCecServiceManager[cecId]->setEventListener(listener);
        }

        if (status != OK) {
            LOGE("%s: Could not set CEC%d message listener!", __PRETTY_FUNCTION__, cecId);
        }
    }
    else
#endif
    {
        LOGE("%s: No CEC%d output on this device!!!", __PRETTY_FUNCTION__, cecId);
    }
    return status;
}

status_t NexusService::setHdmiHotplugEventListener(uint32_t portId, const sp<INexusHdmiHotplugEventListener> &listener)
{
    status_t status = OK;

    ALOGV("%s: HDMI%d listener=%p", __PRETTY_FUNCTION__, portId, listener.get());

#if NEXUS_HAS_HDMI_OUTPUT
    if (portId < NEXUS_NUM_HDMI_OUTPUTS) {
        server->mHdmiHotplugEventListener[portId] = listener;
    }
    else
#endif
    {
        LOGE("%s: No HDMI%d output on this device!!!", __PRETTY_FUNCTION__, portId);
        status = INVALID_OPERATION;
    }
    return status;
}

#undef CHECK_INTERFACE
#define CHECK_INTERFACE(interface, data, reply) \
        do { if (!data.enforceInterface(interface::getInterfaceDescriptor())) { \
            LOGE("Call incorrectly routed to " #interface); \
            return PERMISSION_DENIED;              \
        } } while (0)

status_t NexusService::onTransact(uint32_t code,
                                  const Parcel &data,
                                  Parcel *reply,
                                  uint32_t flags)
{
    CHECK_INTERFACE(INexusService, data, reply);
    
    switch(code) {
    case API_OVER_BINDER: { /* braces are necessary when declaring variables within case: */
        int rc = 0;
        api_data cmd;
        data.read(&cmd, sizeof(cmd));

        switch(cmd.api)
        {
            case api_clientJoin:
            {
                cmd.param.clientJoin.out.clientHandle = 
                    clientJoin(&cmd.param.clientJoin.in.clientName, &cmd.param.clientJoin.in.clientAuthenticationSettings);
                break;
            }
            case api_clientUninit:
            {
                cmd.param.clientUninit.out.status = clientUninit(cmd.param.clientUninit.in.clientHandle);
                break;
            }
            case api_createClientContext:
            {
                cmd.param.createClientContext.out.client = createClientContext(&cmd.param.createClientContext.in.createClientConfig);
                break;
            }
            case api_destroyClientContext:
            {
                destroyClientContext(cmd.param.destroyClientContext.in.client);
                break;
            }
            case api_getClientInfo:
            {
                getClientInfo(cmd.param.getClientInfo.in.client, &cmd.param.getClientInfo.out.info);
                break;
            }
            case api_getClientComposition:
            {
                getClientComposition(cmd.param.getClientComposition.in.client, &cmd.param.getClientComposition.out.composition);
                break;
            }
            case api_setClientComposition:
            {
                setClientComposition(cmd.param.setClientComposition.in.client, &cmd.param.setClientComposition.in.composition);
                break;
            }
            
            case api_getVideoWindowSettings:
            {
                getVideoWindowSettings(cmd.param.getVideoWindowSettings.in.client, cmd.param.getVideoWindowSettings.in.window_id, &cmd.param.getVideoWindowSettings.out.settings);
                break;
            }
            case api_setVideoWindowSettings:
            {
                setVideoWindowSettings(cmd.param.setVideoWindowSettings.in.client, cmd.param.setVideoWindowSettings.in.window_id, &cmd.param.setVideoWindowSettings.in.settings);
                break;
            }
            case api_getDisplaySettings:
            {
                getDisplaySettings(cmd.param.getDisplaySettings.in.display_id, &cmd.param.getDisplaySettings.out.settings);
                break;
            }
            case api_setDisplaySettings:            
            {
                setDisplaySettings(cmd.param.getDisplaySettings.in.display_id, &cmd.param.getDisplaySettings.out.settings);
                break;
            } 

            case api_addGraphicsWindow:
            {
                cmd.param.addGraphicsWindow.out.status = addGraphicsWindow(cmd.param.addGraphicsWindow.in.client);
                break;
            }
            case api_setAudioVolume:
            {
                setAudioVolume(cmd.param.setAudioVolume.in.leftVolume, cmd.param.setAudioVolume.in.rightVolume);
                break;
            }
            case api_getFrame:
            {
                cmd.param.getFrame.out.status = getFrame(cmd.param.getFrame.in.client, cmd.param.getFrame.in.width, cmd.param.getFrame.in.height, 
                    cmd.param.getFrame.in.surfacePhyAddress, cmd.param.getFrame.in.surfaceFormat, cmd.param.getFrame.in.decoderId);
                break;
            }
            case api_setPowerState:
            {
                cmd.param.setPowerState.out.status = setPowerState(cmd.param.setPowerState.in.pmState);
                break;
            }
            case api_getPowerState:
            {
                cmd.param.getPowerState.out.pmState = getPowerState();
                break;
            }
            case api_setCecPowerState:
            {
                cmd.param.setCecPowerState.out.status = setCecPowerState(cmd.param.setCecPowerState.in.cecId,
                                                                         cmd.param.setCecPowerState.in.pmState);
                break;
            }
            case api_getCecPowerStatus:
            {
                cmd.param.getCecPowerStatus.out.status = getCecPowerStatus(cmd.param.getCecPowerStatus.in.cecId,
                                                                          &cmd.param.getCecPowerStatus.out.powerStatus);
                break;
            }
            case api_getCecStatus:
            {
                cmd.param.getCecStatus.out.status = getCecStatus(cmd.param.getCecStatus.in.cecId,
                                                                &cmd.param.getCecStatus.out.cecStatus);
                break;
            }
            case api_sendCecMessage:
            {
                cmd.param.sendCecMessage.out.status = sendCecMessage(cmd.param.sendCecMessage.in.cecId,
                                                                     cmd.param.sendCecMessage.in.srcAddr,
                                                                     cmd.param.sendCecMessage.in.destAddr,
                                                                     cmd.param.sendCecMessage.in.length,
                                                                     cmd.param.sendCecMessage.in.message);
                break;
            }
            case api_setCecLogicalAddress:
            {
                cmd.param.setCecLogicalAddress.out.status = setCecLogicalAddress(cmd.param.setCecLogicalAddress.in.cecId,
                                                                                 cmd.param.setCecLogicalAddress.in.addr);
                break;
            }
            case api_getHdmiOutputStatus:
            {
                cmd.param.getHdmiOutputStatus.out.status = getHdmiOutputStatus(cmd.param.getHdmiOutputStatus.in.portId,
                                                                              &cmd.param.getHdmiOutputStatus.out.hdmiOutputStatus);
                break;
            }
            case api_connectClientResources:
            {
                cmd.param.connectClientResources.out.status = connectClientResources(cmd.param.connectClientResources.in.client,
                                                                                     &cmd.param.connectClientResources.in.connectSettings);
                break;
            }
            case api_disconnectClientResources:
            {
                cmd.param.disconnectClientResources.out.status = disconnectClientResources(cmd.param.disconnectClientResources.in.client);
                break;
            }
            case api_getPictureCtrlCommonSettings:
            {
                getPictureCtrlCommonSettings(cmd.param.getPictureCtrlCommonSettings.in.window_id, &cmd.param.getPictureCtrlCommonSettings.out.settings);
                break;
            }
            case api_setPictureCtrlCommonSettings:            
            {
                setPictureCtrlCommonSettings(cmd.param.setPictureCtrlCommonSettings.in.window_id, &cmd.param.setPictureCtrlCommonSettings.in.settings);
                break;
            } 
            case api_getGraphicsColorSettings:
            {
                getGraphicsColorSettings(cmd.param.getGraphicsColorSettings.in.display_id, &cmd.param.getGraphicsColorSettings.out.settings);
                break;
            }
            case api_setGraphicsColorSettings:            
            {
                setGraphicsColorSettings(cmd.param.setGraphicsColorSettings.in.display_id, &cmd.param.setGraphicsColorSettings.in.settings);
                break;
            } 
            case api_setDisplayOutputs:            
            {
                LOGI("api_setDisplayOutputs: display=%d",cmd.param.setDisplayOutputs.in.display);
                setDisplayOutputs(cmd.param.setDisplayOutputs.in.display);
                break;
            }
            case api_setAudioMute:
            {
                setAudioMute(cmd.param.setAudioMute.in.mute);
                break;
            }
            default:
            {
                LOGE("%s: Unhandled cmd = %d",__PRETTY_FUNCTION__,cmd.api);
                return INVALID_OPERATION;
            }
        } /* switch(cmd.api) */

        if(!rc)
        {
            reply->write(&cmd.param, sizeof(cmd.param));
            return NO_ERROR;
        }
        else
        {
            return FAILED_TRANSACTION;
        }
    } break; 

    case SET_HDMI_CEC_MESSAGE_EVENT_LISTENER: {
        uint32_t cecId = data.readInt32();
        sp<INexusHdmiCecMessageEventListener> listener = interface_cast<INexusHdmiCecMessageEventListener>(data.readStrongBinder());
        reply->writeInt32(setHdmiCecMessageEventListener(cecId, listener));
        return NO_ERROR;
    } break;

    case SET_HDMI_HOTPLUG_EVENT_LISTENER: {
        uint32_t portId = data.readInt32();
        sp<INexusHdmiHotplugEventListener> listener = interface_cast<INexusHdmiHotplugEventListener>(data.readStrongBinder());
        reply->writeInt32(setHdmiHotplugEventListener(portId, listener));
        return NO_ERROR;
    } break;

    default:
        LOGE("ERROR! No such transaction(%d) in nexus service", code);
        return BBinder::onTransact(code, data, reply, flags);
        break;
    }/* switch(code) */

    return NO_ERROR;
}

