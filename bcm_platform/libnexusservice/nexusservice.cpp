/******************************************************************************
 *    (c)2010-2015 Broadcom Corporation
 * 
 * This program is the proprietary software of Broadcom Corporation and/or its licensors,
 * and may only be used, duplicated, modified or distributed pursuant to the terms and
 * conditions of a separate, written license agreement executed between you and Broadcom
 * (an "Authorized License").  Except as set forth in an Authorized License, Broadcom grants
 * no license (express or implied), right to use, or waiver of any kind with respect to the
 * Software, and Broadcom expressly reserves all rights in and to the Software and all
 * intellectual property rights therein.  IF YOU HAVE NO AUTHORIZED LICENSE, THEN YOU
 * HAVE NO RIGHT TO USE THIS SOFTWARE IN ANY WAY, AND SHOULD IMMEDIATELY
 * NOTIFY BROADCOM AND DISCONTINUE ALL USE OF THE SOFTWARE.  
 *  
 * Except as expressly set forth in the Authorized License,
 *  
 * 1.     This program, including its structure, sequence and organization, constitutes the valuable trade
 * secrets of Broadcom, and you shall use all reasonable efforts to protect the confidentiality thereof,
 * and to use this information only in connection with your use of Broadcom integrated circuit products.
 *  
 * 2.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, THE SOFTWARE IS PROVIDED "AS IS" 
 * AND WITH ALL FAULTS AND BROADCOM MAKES NO PROMISES, REPRESENTATIONS OR 
 * WARRANTIES, EITHER EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE, WITH RESPECT TO 
 * THE SOFTWARE.  BROADCOM SPECIFICALLY DISCLAIMS ANY AND ALL IMPLIED WARRANTIES 
 * OF TITLE, MERCHANTABILITY, NONINFRINGEMENT, FITNESS FOR A PARTICULAR PURPOSE, 
 * LACK OF VIRUSES, ACCURACY OR COMPLETENESS, QUIET ENJOYMENT, QUIET POSSESSION 
 * OR CORRESPONDENCE TO DESCRIPTION. YOU ASSUME THE ENTIRE RISK ARISING OUT OF 
 * USE OR PERFORMANCE OF THE SOFTWARE.
 * 
 * 3.     TO THE MAXIMUM EXTENT PERMITTED BY LAW, IN NO EVENT SHALL BROADCOM OR ITS 
 * LICENSORS BE LIABLE FOR (i) CONSEQUENTIAL, INCIDENTAL, SPECIAL, INDIRECT, OR 
 * EXEMPLARY DAMAGES WHATSOEVER ARISING OUT OF OR IN ANY WAY RELATING TO YOUR 
 * USE OF OR INABILITY TO USE THE SOFTWARE EVEN IF BROADCOM HAS BEEN ADVISED OF 
 * THE POSSIBILITY OF SUCH DAMAGES; OR (ii) ANY AMOUNT IN EXCESS OF THE AMOUNT 
 * ACTUALLY PAID FOR THE SOFTWARE ITSELF OR U.S. $1, WHICHEVER IS GREATER. THESE 
 * LIMITATIONS SHALL APPLY NOTWITHSTANDING ANY FAILURE OF ESSENTIAL PURPOSE OF 
 * ANY LIMITED REMEDY.
 *
 * $brcm_Workfile: nexusservice.cpp $
 * 
 *****************************************************************************/

//#define LOG_NDEBUG 0

#include <utils/Log.h>

#include <sys/types.h>
#include <sys/stat.h>
#include <dirent.h>
#include <unistd.h>

#include <string.h>
#include <cutils/atomic.h>
#include <utils/Errors.h>
#include <binder/IServiceManager.h>
#include <utils/String16.h>
#include <utils/Vector.h>
#include "cutils/properties.h"

#include "nexusservice.h"
#include "nexuscecservice.h"

#include "nexus_base_mmap.h"

extern "C" {
#include "namevalue.h"
#include "namevalue.inc"
}

#include "nexus_ipc_priv.h"

#ifdef LOG_TAG
#undef LOG_TAG
#endif
#define LOG_TAG "NexusService"

#ifdef UINT32_C
#undef UINT32_C
#define UINT32_C(x)  (x ## U)
#endif

/* The main heap normally has full access */
#ifdef NEXUS_PLATFORM_DEFAULT_HEAP
#define NEXUS_MAIN_HEAP_IDX NEXUS_PLATFORM_DEFAULT_HEAP
#else
#define NEXUS_MAIN_HEAP_IDX NEXUS_MEMC0_MAIN_HEAP
#endif

#define NX_HD_OUT_FMT                  "nx.vidout.force" /* needs prefixing. */

BDBG_OBJECT_ID(NexusClientContext);

#if ANDROID_ENABLE_HDMI_HDCP
#include "nexus_hdmi_output.h"
#include "nexus_hdmi_output_hdcp.h"

/*****************/
/* For HDCP TESTING */
/* 1) insert the Production Key Set set generated by BCrypt */
/* 2) set the USE_PRODUCTION_KEYS macro to to 1 */
/*****************/
#define USE_PRODUCTION_KEYS 0
#if USE_PRODUCTION_KEYS
/*****************************/
/* INSERT PRODUCTION KeySet HERE */
/*****************************/
#else
/**************************************/
/* HDCP Specification Test Key Set */
/* */
/* NOTE: the default declared Test */
/* KeySet below is from the HDCP Spec */
/* and it *IS NOT* compatible with */
/* production devices */
/**************************************/

static NEXUS_HdmiOutputHdcpKsv hdcpTxAksv =
{ {0x14, 0xF7, 0x61, 0x03, 0xB7} };

static NEXUS_HdmiOutputHdcpKey encryptedTxKeySet[NEXUS_HDMI_OUTPUT_HDCP_NUM_KEYS] =
{
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x691e138f, 0x58a44d00},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x0950e658, 0x35821f00},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x0d98b9ab, 0x476a8a00},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xcac5cb52, 0x1b18f300},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xb4d89668, 0x7f14fb00},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x818f4878, 0xc98be000},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x412c11c8, 0x64d0a000},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x44202428, 0x5a9db300},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x6b56adbd, 0xb228b900},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xf6e46c4a, 0x7ba49100},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x589d5e20, 0xf8005600},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xa03fee06, 0xb77f8c00},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x28bc7c9d, 0x8c2dc000},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x059f4be5, 0x61125600},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xcbc1ca8c, 0xdef07400},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x6adbfc0e, 0xf6b83b00},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xd72fb216, 0xbb2ba000},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x98547846, 0x8e2f4800},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x38472762, 0x25ae6600},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xf2dd23a3, 0x52493d00},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x543a7b76, 0x31d2e200},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x2561e6ed, 0x1a584d00},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xf7227bbf, 0x82603200},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x6bce3035, 0x461bf600},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x6b97d7f0, 0x09043600},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xf9498d61, 0x05e1a100},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x063405d1, 0x9d8ec900},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x90614294, 0x67c32000},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xc34facce, 0x51449600},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x8a8ce104, 0x45903e00},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xfc2d9c57, 0x10002900},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x80b1e569, 0x3b94d700},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x437bdd5b, 0xeac75400},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xba90c787, 0x58fb7400},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xe01d4e36, 0xfa5c9300},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xae119a15, 0x5e070300},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x01fb788a, 0x40d30500},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0xb34da0d7, 0xa5590000},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x409e2c4a, 0x633b3700},
    { 0, 0, 0, 0, 0, 0, 0, 0, 0x412056b4, 0xbb732500}
} ;
#endif

/*
  from HDCP Spec:
  Table 51 gives the format of the HDCP SRM. All values are stored in big endian format.

  Specify KSVs here in big endian;
*/
#define NUM_REVOKED_KSVS 3
static uint8_t NumRevokedKsvs = NUM_REVOKED_KSVS ;
static const NEXUS_HdmiOutputHdcpKsv RevokedKsvs[NUM_REVOKED_KSVS] =
{
    /* MSB ... LSB */
    {{0xa5, 0x1f, 0xb0, 0xc3, 0x72}},
    {{0x65, 0xbf, 0x04, 0x8a, 0x7c}},
    {{0x65, 0x65, 0x1e, 0xd5, 0x64}}
} ;

void NexusService::hdmiOutputHdcpStateChangedCallback(void *pContext, int param __unused)
{
    bool success = false ;
    NEXUS_HdmiOutputHandle handle = (NEXUS_HdmiOutputHandle)pContext;
    NEXUS_HdmiOutputHdcpStatus hdcpStatus;

    NEXUS_HdmiOutput_GetHdcpStatus(handle, &hdcpStatus);

    switch (hdcpStatus.hdcpError) {
    case NEXUS_HdmiOutputHdcpError_eSuccess :
        ALOGE("HDCP Authentication Successful\n");
        success = true ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eRxBksvError :
        ALOGE("HDCP Rx BKsv Error") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eRxBksvRevoked :
        ALOGE("HDCP Rx BKsv/Keyset Revoked") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eRxBksvI2cReadError :
    case NEXUS_HdmiOutputHdcpError_eTxAksvI2cWriteError :
        ALOGE("HDCP I2C Read Error") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eTxAksvError :
        ALOGE("HDCP Tx Aksv Error") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eReceiverAuthenticationError :
        ALOGE("HDCP Receiver Authentication Failure") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eRepeaterAuthenticationError :
    case NEXUS_HdmiOutputHdcpError_eRepeaterLinkFailure : /* Repeater Error; unused */
        ALOGE("HDCP Repeater Authentication Failure") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eRxDevicesExceeded :
        ALOGE("HDCP Repeater MAX Downstram Devices Exceeded") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eRepeaterDepthExceeded :
        ALOGE("HDCP Repeater MAX Downstram Levels Exceeded") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eRepeaterFifoNotReady :
        ALOGE("Timeout waiting for Repeater") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eRepeaterDeviceCount0 : /* unused */
        break ;

    case NEXUS_HdmiOutputHdcpError_eLinkRiFailure :
        ALOGE("HDCP Ri Integrity Check Failure") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eLinkPjFailure :
        ALOGE("HDCP Pj Integrity Check Failure") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eFifoUnderflow :
    case NEXUS_HdmiOutputHdcpError_eFifoOverflow :
        ALOGE("Video configuration issue") ;
        break ;

    case NEXUS_HdmiOutputHdcpError_eMultipleAnRequest : /* Should not reach here; but flag if occurs */
        ALOGE("Multiple Authentication Request... ") ;

    default :
        ALOGE("Unknown HDCP Authentication Error %d", hdcpStatus.hdcpError) ;
    }

    if (!success) {
        ALOGE("\nHDCP Authentication Failed. Current State %d\n", hdcpStatus.hdcpState);
        /* always retry */
        NEXUS_HdmiOutput_StartHdcpAuthentication(handle);
    }
}
#endif // ANDROID_ENABLE_HDMI_HDCP

typedef struct NexusClientContext {
    BDBG_OBJECT(NexusClientContext)
    BLST_D_ENTRY(NexusClientContext) link;
    struct {
        NEXUS_ClientHandle nexusClient;
        unsigned connectId;
    } ipc;
    b_refsw_client_client_name clientName;
    unsigned                   clientPid;
    b_refsw_client_client_info info;
} NexusClientContext;

NexusServerContext::NexusServerContext() : mLock(Mutex::SHARED), mJoinRefCount(0)
{
    BLST_D_INIT(&clients);
    lastId.client = 0;
}

const String16 INexusService::descriptor(NEXUS_INTERFACE_NAME);

String16 INexusService::getInterfaceDescriptor() {
        return INexusService::descriptor;
}

NEXUS_ClientHandle NexusService::getNexusClient(unsigned pid)
{
    NEXUS_PlatformObjectInstance *objects = NULL;
    NEXUS_ClientHandle nexusClient = NULL;
    NEXUS_InterfaceName interfaceName;
    unsigned num = 16; /* starting size. */
    unsigned max_num = 1024; /* some big value. */
    unsigned i, cached_num;
    int rc;

    NEXUS_Platform_GetDefaultInterfaceName(&interfaceName);
    strcpy(interfaceName.name, "NEXUS_Client");
    do {
        cached_num = num;
        if (objects != NULL) {
           BKNI_Free(objects);
        }
        objects = (NEXUS_PlatformObjectInstance *)BKNI_Malloc(num*sizeof(NEXUS_PlatformObjectInstance));
        if (objects == NULL) {
            ALOGE("%s: FATAL: Could not allocate memory to hold %d Nexus platform objects!!!", __FUNCTION__, num);
            BDBG_ASSERT(false);
        }
        rc = NEXUS_Platform_GetObjects(&interfaceName, objects, num, &num);
        if (rc == NEXUS_PLATFORM_ERR_OVERFLOW) {
            if (num > max_num) {
               rc = NEXUS_SUCCESS;
               num = 0;
               ALOGW("%s: NEXUS_Platform_GetObjects overflowed - giving up...", __FUNCTION__);
            } else if (num <= cached_num) {
               num = 2 * cached_num;
            }
        }
    } while (rc == NEXUS_PLATFORM_ERR_OVERFLOW);

    for (i=0; i < num; i++) {
        NEXUS_ClientStatus status;
        unsigned j;
        rc = NEXUS_Platform_GetClientStatus(reinterpret_cast<NEXUS_ClientHandle>(objects[i].object), &status);
        if (rc) continue;

        if (status.pid == pid) {
            nexusClient = reinterpret_cast<NEXUS_ClientHandle>(objects[i].object);
            break;
        }
    }

    if (objects != NULL) {
       BKNI_Free(objects);
    }
    return nexusClient;
}

void NexusService::hdmiOutputHotplugCallback(void *context __unused, int param __unused)
{
#if NEXUS_HAS_HDMI_OUTPUT
    NEXUS_HdmiOutputStatus       status;
    NEXUS_PlatformConfiguration *pPlatformConfig;
    NEXUS_HdmiOutputHandle       hdmiOutput;
    NEXUS_HdmiOutputSettings     hdmiSettings;
    NexusService *               pNexusService;

    pNexusService = reinterpret_cast<NexusService *>(context);

    pPlatformConfig = reinterpret_cast<NEXUS_PlatformConfiguration *>(BKNI_Malloc(sizeof(*pPlatformConfig)));
    if (pPlatformConfig == NULL) {
        ALOGE("%s: Could not allocate enough memory for the platform configuration!!!", __FUNCTION__);
    }
    else {
        NEXUS_Platform_GetConfiguration(pPlatformConfig);
        hdmiOutput = pPlatformConfig->outputs.hdmi[param];
        BKNI_Free(pPlatformConfig);

        NEXUS_HdmiOutput_GetStatus(hdmiOutput, &status);

        ALOGD("%s: HDMI%d hotplug %s (receive device %s powered)", __func__, param, status.connected ? "connected" : "disconnected", status.rxPowered ? "is" : "isn't");

        /* force HDMI updates after a hotplug */
        NEXUS_HdmiOutput_GetSettings(hdmiOutput, &hdmiSettings) ;
        NEXUS_HdmiOutput_SetSettings(hdmiOutput, &hdmiSettings) ;

        // Ensure that CEC Physical Address is updated on a "connected" hot-plug event...
        if (NEXUS_NUM_CEC > 0 && status.connected) {
            b_hdmiOutputStatus hdmiOutputStatus;
            uint16_t addr;

            if (pNexusService->getHdmiOutputStatus(param, &hdmiOutputStatus)) {
                addr = hdmiOutputStatus.physicalAddress[0] * 256 + hdmiOutputStatus.physicalAddress[1];

                if (pNexusService->mCecServiceManager[param].get() != NULL &&
                    pNexusService->mCecServiceManager[param]->isPlatformInitialised() &&
                    pNexusService->setCecPhysicalAddress(param, addr)) {
                    ALOGD("%s: Set CEC%d physical address to %01d.%01d.%01d.%01d", __PRETTY_FUNCTION__, param,
                    (addr >> 12) & 0x0F,
                    (addr >>  8) & 0x0F,
                    (addr >>  4) & 0x0F,
                    (addr >>  0) & 0x0F);
                }
                else {
                    ALOGE("%s: Could not set CEC%d physical address!!!", __PRETTY_FUNCTION__, param);
                }
            }
            else {
                ALOGW("%s: Could not get HDMI%d output status!", __PRETTY_FUNCTION__, param);
            }
        }

        /* restart HDCP if it was previously enabled */
        NEXUS_HdmiOutput_StartHdcpAuthentication(hdmiOutput);

        Vector<sp<INexusHdmiHotplugEventListener> >::const_iterator it;

        Mutex::Autolock autoLock(pNexusService->server->mLock);

        for (it = pNexusService->server->mHdmiHotplugEventListenerList[param].begin(); it != pNexusService->server->mHdmiHotplugEventListenerList[param].end(); ++it) {
            ALOGV("%s: Firing off HDMI%d hotplug %s event for listener %p...", __PRETTY_FUNCTION__, param,
                 (status.connected && status.rxPowered) ? "connected" : "disconnected", (*it).get());
            (*it)->onHdmiHotplugEventReceived(param, status.connected && status.rxPowered);
        }
    }
#endif
}

int NexusService::platformSetupHdmiOutputs()
{
    int rc = 0;
#if NEXUS_HAS_HDMI_OUTPUT
    NEXUS_PlatformConfiguration *pPlatformConfig;

    pPlatformConfig = reinterpret_cast<NEXUS_PlatformConfiguration *>(BKNI_Malloc(sizeof(*pPlatformConfig)));
    if (pPlatformConfig == NULL) {
        ALOGE("%s: Could not allocate enough memory for the platform configuration!!!", __FUNCTION__);
        return NEXUS_OUT_OF_SYSTEM_MEMORY;
    }

    NEXUS_Platform_GetConfiguration(pPlatformConfig);

    for (int index = 0; index < NEXUS_NUM_HDMI_OUTPUTS; index++) {
        NEXUS_HdmiOutputHandle       hdmiOutput;
        NEXUS_HdmiOutputSettings     hdmiSettings;

        hdmiOutput = pPlatformConfig->outputs.hdmi[index];
        NEXUS_HdmiOutput_GetSettings(hdmiOutput, &hdmiSettings);
        hdmiSettings.hotplugCallback.callback = hdmiOutputHotplugCallback;
        hdmiSettings.hotplugCallback.context = this;
        hdmiSettings.hotplugCallback.param = index;
        rc = NEXUS_HdmiOutput_SetSettings(hdmiOutput, &hdmiSettings);
        if (rc) {
            ALOGE("%s: Could not set HDMI%d output settings!!!", __PRETTY_FUNCTION__, index);
        }
#if ANDROID_ENABLE_HDMI_HDCP
        /* initalize HDCP settings, keys, etc. */
        NEXUS_HdmiOutputHdcpSettings hdmiOutputHdcpSettings;

        NEXUS_HdmiOutput_GetHdcpSettings(hdmiOutput, &hdmiOutputHdcpSettings);

        /* copy the encrypted key set and its Aksv here */
        BKNI_Memcpy(hdmiOutputHdcpSettings.encryptedKeySet, encryptedTxKeySet, NEXUS_HDMI_OUTPUT_HDCP_NUM_KEYS * sizeof(NEXUS_HdmiOutputHdcpKey));
        BKNI_Memcpy(&hdmiOutputHdcpSettings.aksv, &hdcpTxAksv, NEXUS_HDMI_OUTPUT_HDCP_KSV_LENGTH);

        /* install HDCP success callback */
        hdmiOutputHdcpSettings.successCallback.callback = hdmiOutputHdcpStateChangedCallback;
        hdmiOutputHdcpSettings.successCallback.context = hdmiOutput;

        /* install HDCP failure callback */
        hdmiOutputHdcpSettings.failureCallback.callback = hdmiOutputHdcpStateChangedCallback;
        hdmiOutputHdcpSettings.failureCallback.context = hdmiOutput;

        NEXUS_HdmiOutput_SetHdcpSettings(hdmiOutput, &hdmiOutputHdcpSettings);

        /* install list of revoked KSVs from SRMs (System Renewability Message) if available */
        NEXUS_HdmiOutput_SetHdcpRevokedKsvs(hdmiOutput, RevokedKsvs, NumRevokedKsvs) ;
        NEXUS_HdmiOutput_StartHdcpAuthentication(hdmiOutput);
#endif
    }
    BKNI_Free(pPlatformConfig);
#endif
    return rc;
}

void NexusService::platformCleanHdmiOutputs()
{
#if NEXUS_HAS_HDMI_OUTPUT
    NEXUS_PlatformConfiguration *pPlatformConfig;

    pPlatformConfig = reinterpret_cast<NEXUS_PlatformConfiguration *>(BKNI_Malloc(sizeof(*pPlatformConfig)));
    if (pPlatformConfig == NULL) {
        ALOGE("%s: Could not allocate enough memory for the platform configuration!!!", __FUNCTION__);
        return;
    }

    NEXUS_Platform_GetConfiguration(pPlatformConfig);

    for (int index = 0; index < NEXUS_NUM_HDMI_OUTPUTS; index++) {
        NEXUS_HdmiOutputHandle      hdmiOutput;
        NEXUS_HdmiOutputSettings    hdmiSettings;

        hdmiOutput = pPlatformConfig->outputs.hdmi[index];

#if ANDROID_ENABLE_HDMI_HDCP
        NEXUS_HdmiOutputHdcpSettings hdmiOutputHdcpSettings;

        NEXUS_HdmiOutput_DisableHdcpAuthentication(hdmiOutput);

        NEXUS_HdmiOutput_GetHdcpSettings(hdmiOutput, &hdmiOutputHdcpSettings);
        hdmiOutputHdcpSettings.successCallback.callback = NULL;
        hdmiOutputHdcpSettings.successCallback.context = NULL;
        hdmiOutputHdcpSettings.failureCallback.callback = NULL;
        hdmiOutputHdcpSettings.failureCallback.context = NULL;
        NEXUS_HdmiOutput_SetHdcpSettings(hdmiOutput, &hdmiOutputHdcpSettings);
#endif
        NEXUS_HdmiOutput_GetSettings(hdmiOutput, &hdmiSettings);
        hdmiSettings.hotplugCallback.callback = NULL;
        hdmiSettings.hotplugCallback.context = NULL;
        hdmiSettings.hotplugCallback.param = 0;
        if (NEXUS_HdmiOutput_SetSettings(hdmiOutput, &hdmiSettings)) {
            ALOGE("%s: Could not set HDMI%d output settings!!!", __PRETTY_FUNCTION__, index);
        }
    }
    BKNI_Free(pPlatformConfig);
#endif
}

NEXUS_VideoFormat NexusService::getForcedOutputFormat(void)
{
   NEXUS_VideoFormat forced_format = NEXUS_VideoFormat_eUnknown;
   char value[PROPERTY_VALUE_MAX];
   char name[PROPERTY_VALUE_MAX];

   memset(value, 0, sizeof(value));
   sprintf(name, "persist.%s", NX_HD_OUT_FMT);
   if (property_get(name, value, "")) {
      if (strlen(value)) {
         forced_format = (NEXUS_VideoFormat)lookup(g_videoFormatStrs, value);
      }
   }

   if ((forced_format == NEXUS_VideoFormat_eUnknown) || (forced_format >= NEXUS_VideoFormat_eMax)) {
      memset(value, 0, sizeof(value));
      sprintf(name, "ro.%s", NX_HD_OUT_FMT);
      if (property_get(name, value, "")) {
         if (strlen(value)) {
            forced_format = (NEXUS_VideoFormat)lookup(g_videoFormatStrs, value);
         }
      }
   }

   return forced_format;
}

void NexusService::platformInit()
{
    int                                i=0;

    if (platformSetupHdmiOutputs() != 0) {
       ALOGE("%s: Could not initialise HDMI output(s)!!!", __PRETTY_FUNCTION__);
       BDBG_ASSERT(false);
    }

    i = NEXUS_NUM_CEC;
    while (i--) {
        mCecServiceManager[i] = CecServiceManager::instantiate(this, i);

        if (mCecServiceManager[i].get() != NULL) {
            if (mCecServiceManager[i]->platformInit() != OK) {
                ALOGE("%s: ERROR initialising CecServiceManager platform for CEC%d!", __PRETTY_FUNCTION__, i);
                mCecServiceManager[i] = NULL;
            }
        }
        else {
            ALOGE("%s: ERROR instantiating CecServiceManager for CEC%d!", __PRETTY_FUNCTION__, i);
        }
    }
}

void NexusService::platformUninit()
{
    platformCleanHdmiOutputs();

    unsigned i = NEXUS_NUM_CEC;

    while (i--) {
        if (mCecServiceManager[i].get() != NULL) {
            mCecServiceManager[i]->platformUninit();
            mCecServiceManager[i] = NULL;
        }
    }
}

void NexusService::instantiate() {
    NexusServerContext *server = new NexusServerContext();

    if (server == NULL) {
        ALOGE("%s: FATAL: Could not allocate memory for NexusServerContext!", __PRETTY_FUNCTION__);
        BDBG_ASSERT(server != NULL);
    }

    NexusService *nexusservice = new NexusService();

    if (nexusservice != NULL) {
        nexusservice->platformInit();
        nexusservice->server = server;

        defaultServiceManager()->addService(
                    INexusService::descriptor, nexusservice);
    }
    else {
        ALOGE("%s: Could not instantiate NexusService!!!", __PRETTY_FUNCTION__);
    }
}

NexusService::NexusService() : powerState(ePowerState_S0)
{
}

NexusService::~NexusService()
{
    platformUninit();

    delete server;
    server = NULL;
}

NEXUS_ClientHandle NexusService::clientJoin(const b_refsw_client_client_name *pClientName, NEXUS_ClientAuthenticationSettings *pClientAuthenticationSettings)
{
    NEXUS_ClientHandle nexusClient;

    Mutex::Autolock autoLock(server->mLock);

    nexusClient = NULL;

    pClientAuthenticationSettings->certificate.length =
        BKNI_Snprintf((char *)pClientAuthenticationSettings->certificate.data,
                      sizeof(pClientAuthenticationSettings->certificate.data),
                      "%u,%#x%#x,%s", server->lastId.client, lrand48(), lrand48(), pClientName->string);

    if (pClientAuthenticationSettings->certificate.length >= sizeof(pClientAuthenticationSettings->certificate.data)-1) {
        ALOGE("%s: Invalid certificate length %d for client \"%s\"!!!", __PRETTY_FUNCTION__, pClientAuthenticationSettings->certificate.length, pClientName->string);
        (void)BERR_TRACE(BERR_NOT_SUPPORTED);
    }
    else {
        NEXUS_PlatformConfiguration *pPlatformConfig;
        NEXUS_ClientSettings         clientSettings;

        pPlatformConfig = reinterpret_cast<NEXUS_PlatformConfiguration *>(BKNI_Malloc(sizeof(*pPlatformConfig)));
        if (pPlatformConfig == NULL) {
            ALOGE("%s: Could not allocate enough memory for the platform configuration!!!", __FUNCTION__);
            (void)BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
        }
        else {
            NEXUS_Platform_GetDefaultClientSettings(&clientSettings);
            clientSettings.authentication.certificate = pClientAuthenticationSettings->certificate;
            NEXUS_Platform_GetConfiguration(pPlatformConfig);
            clientSettings.configuration.heap[0] = NEXUS_Platform_GetFramebufferHeap(NEXUS_OFFSCREEN_SURFACE);
            clientSettings.configuration.heap[1] = pPlatformConfig->heap[NEXUS_MAIN_HEAP_IDX];
#ifdef NEXUS_VIDEO_SECURE_HEAP
            clientSettings.configuration.heap[2] = pPlatformConfig->heap[NEXUS_VIDEO_SECURE_HEAP];
#endif
#ifdef NEXUS_SECONDARY_OFFSCREEN_SURFACE
            clientSettings.configuration.heap[3] = NEXUS_Platform_GetFramebufferHeap(NEXUS_SECONDARY_OFFSCREEN_SURFACE);
            if (clientSettings.configuration.heap[3] == clientSettings.configuration.heap[0]) {
                clientSettings.configuration.heap[3] = NULL;
            }
#endif
            nexusClient = NEXUS_Platform_RegisterClient(&clientSettings);
            if (nexusClient) {
                server->lastId.client++;
                server->mJoinRefCount++;
            }
            else {
                (void)BERR_TRACE(BERR_NOT_SUPPORTED);
            }
            BKNI_Free(pPlatformConfig);
        }
    }
    return nexusClient;
}

NEXUS_Error NexusService::clientUninit(NEXUS_ClientHandle nexusClient)
{
    NEXUS_Error rc;

    Mutex::Autolock autoLock(server->mLock);

    server->mJoinRefCount--;

    if (nexusClient == NULL) {
        rc = NEXUS_INVALID_PARAMETER;
    } else {
        NEXUS_Platform_UnregisterClient(nexusClient);
        rc = NEXUS_SUCCESS;
    }
    return rc;
}

NexusClientContext * NexusService::createClientContext(const b_refsw_client_client_name *pClientName, unsigned clientPid)
{
    NexusClientContext * client;
    NEXUS_ClientSettings clientSettings;
    NEXUS_Error rc;

    Mutex::Autolock autoLock(server->mLock);

    client = (NexusClientContext *)BKNI_Malloc(sizeof(NexusClientContext));
    if (client==NULL) {
        (void)BERR_TRACE(BERR_OUT_OF_SYSTEM_MEMORY);
        return NULL;
    }

    BKNI_Memset(client, 0, sizeof(*client));
    BDBG_OBJECT_SET(client, NexusClientContext);

    client->clientName = *pClientName;
    client->clientPid = clientPid;

    BLST_D_INSERT_HEAD(&server->clients, client, link);

    client->ipc.nexusClient = getNexusClient(clientPid);

    if (powerState != ePowerState_S0) {
        NEXUS_PlatformStandbySettings nexusStandbySettings;

        ALOGI("We need to set Nexus Power State S0 first...");
        NEXUS_Platform_GetStandbySettings(&nexusStandbySettings);
        nexusStandbySettings.mode = NEXUS_PlatformStandbyMode_eOn;
        rc = NEXUS_Platform_SetStandbySettings(&nexusStandbySettings);
        if (rc != NEXUS_SUCCESS) {
            ALOGE("Oops we couldn't set Nexus Power State to S0!");
            goto err_client;
        }
        else {
            ALOGI("Successfully set Nexus Power State S0");
        }
    }
    ALOGI("%s: Exiting with client=%p, name=\"%s\"", __PRETTY_FUNCTION__, (void *)client, pClientName->string);
    return client;

err_client:
    /* todo fix cleanup */
    return NULL;
}

void NexusService::destroyClientContext(NexusClientContext * client)
{
    Mutex::Autolock autoLock(server->mLock);

    BDBG_OBJECT_ASSERT(client, NexusClientContext);
    if(client->ipc.nexusClient) {
        client->ipc.nexusClient = NULL;
    }
    BLST_D_REMOVE(&server->clients, client, link);
    BDBG_OBJECT_DESTROY(client, NexusClientContext);
    BKNI_Free(client);
}

bool NexusService::isCecEnabled(uint32_t cecId __unused)
{
    bool enabled = false;
    char value[PROPERTY_VALUE_MAX];

    if (NEXUS_NUM_CEC > 0 && property_get(PROPERTY_HDMI_ENABLE_CEC, value, DEFAULT_PROPERTY_HDMI_ENABLE_CEC) && (strcmp(value,"1")==0 || strcmp(value, "true")==0)) {
        enabled = true;
    }
    return enabled;
}

bool NexusService::setCecAutoWakeupEnabled(uint32_t cecId __unused, bool enabled)
{
    bool success = true;
    char value[PROPERTY_VALUE_MAX];

    snprintf(value, PROPERTY_VALUE_MAX, "%d", enabled);

    if (property_set(PROPERTY_HDMI_AUTO_WAKEUP_CEC, value) != 0) {
        success = false;
    }
    return success;
}

bool NexusService::isCecAutoWakeupEnabled(uint32_t cecId __unused)
{
    bool enabled = false;
    char value[PROPERTY_VALUE_MAX];

    if (property_get(PROPERTY_HDMI_AUTO_WAKEUP_CEC, value, DEFAULT_PROPERTY_HDMI_AUTO_WAKEUP_CEC) && (strcmp(value,"1")==0 || strcmp(value, "true")==0)) {
        enabled = true;
    }
    return enabled;
}

b_cecDeviceType NexusService::toCecDeviceType(char *string)
{
    b_cecDeviceType deviceType;
    int type = atoi(string);

    switch (type) {
        case -1:
            deviceType = eCecDeviceType_eInactive;
            break;
        case 0:
            deviceType = eCecDeviceType_eTv;
            break;
        case 1:
            deviceType = eCecDeviceType_eRecordingDevice;
            break;
        case 2:
            deviceType = eCecDeviceType_eReserved;
            break;
        case 3:
            deviceType = eCecDeviceType_eTuner;
            break;
        case 4:
            deviceType = eCecDeviceType_ePlaybackDevice;
            break;
        case 5:
            deviceType = eCecDeviceType_eAudioSystem;
            break;
        case 6:
            deviceType = eCecDeviceType_ePureCecSwitch;
            break;
        case 7:
            deviceType = eCecDeviceType_eVideoProcessor;
            break;
        default:
            deviceType = eCecDeviceType_eInvalid;
    }
    return deviceType;
}

/* Android-L sets up a property to define the device type and hence
   the logical address of the device.  */
b_cecDeviceType NexusService::getCecDeviceType(uint32_t cecId __unused)
{
    char value[PROPERTY_VALUE_MAX];
    b_cecDeviceType type = eCecDeviceType_eInvalid;

    if (property_get("ro.hdmi.device_type", value, NULL)) {
        type = NexusService::toCecDeviceType(value);
    }
    return type;
}

bool NexusService::setCecLogicalAddress(unsigned cecId, uint8_t addr)
{
    bool success = false;

    if (mCecServiceManager[cecId].get() != NULL && mCecServiceManager[cecId]->isPlatformInitialised()) {
        success = mCecServiceManager[cecId]->setLogicalAddress(addr);
    }

    if (!success) {
        ALOGE("%s: Could not set CEC%d logical address to 0x%02x!", __PRETTY_FUNCTION__, cecId, addr);
    }
    return success;
}

bool NexusService::setCecPhysicalAddress(unsigned cecId, uint16_t addr)
{
    bool success = false;

    if (mCecServiceManager[cecId].get() != NULL && mCecServiceManager[cecId]->isPlatformInitialised()) {
        success = mCecServiceManager[cecId]->setPhysicalAddress(addr);
    }

    if (!success) {
        ALOGE("%s: Could not set CEC%d physical address to %01d.%01d.%01d.%01d", __PRETTY_FUNCTION__, cecId,
            (addr >> 12) & 0x0F,
            (addr >>  8) & 0x0F,
            (addr >>  4) & 0x0F,
            (addr >>  0) & 0x0F);
    }
    return success;
}

bool NexusService::setCecPowerState(unsigned cecId, b_powerState pmState)
{
    bool success = false;

    if (mCecServiceManager[cecId].get() != NULL && mCecServiceManager[cecId]->isPlatformInitialised()) {
        success = mCecServiceManager[cecId]->setPowerState(pmState);
    }

    if (!success) {
        ALOGE("%s: Could not set CEC%d power state %s!", __PRETTY_FUNCTION__, cecId, NexusService::getPowerString(pmState));
    }
    return success;
}

bool NexusService::getCecPowerStatus(uint32_t cecId, uint8_t *pPowerStatus)
{
    bool success = false;

    if (mCecServiceManager[cecId].get() != NULL && mCecServiceManager[cecId]->isPlatformInitialised()) {
        success = mCecServiceManager[cecId]->getPowerStatus(pPowerStatus);
    }

    if (!success) {
        ALOGE("%s: Could not get CEC%d TV power status!", __PRETTY_FUNCTION__, cecId);
    }
    return success;
}

bool NexusService::getCecStatus(uint32_t cecId, b_cecStatus *pCecStatus)
{
    bool success = false;

    if (mCecServiceManager[cecId].get() != NULL && mCecServiceManager[cecId]->isPlatformInitialised()) {
        success = mCecServiceManager[cecId]->getCecStatus(pCecStatus);
    }

    if (!success) {
        ALOGE("%s: Could not get CEC%d TV status!", __PRETTY_FUNCTION__, cecId);
    }
    return success;
}

bool NexusService::getHdmiOutputStatus(uint32_t portId, b_hdmiOutputStatus *pHdmiOutputStatus)
{
    NEXUS_Error rc = NEXUS_NOT_SUPPORTED;
#if NEXUS_HAS_HDMI_OUTPUT
    if (portId < NEXUS_NUM_HDMI_OUTPUTS) {
        unsigned loops;
        NEXUS_HdmiOutputHandle hdmiOutput;
        NEXUS_PlatformConfiguration *pPlatformConfig;
        NEXUS_HdmiOutputStatus status;

        memset(pHdmiOutputStatus, 0, sizeof(*pHdmiOutputStatus));

        pPlatformConfig = reinterpret_cast<NEXUS_PlatformConfiguration *>(BKNI_Malloc(sizeof(*pPlatformConfig)));
        if (pPlatformConfig == NULL) {
            ALOGE("%s: Could not allocate enough memory for the platform configuration!!!", __FUNCTION__);
            return false;
        }
        NEXUS_Platform_GetConfiguration(pPlatformConfig);
        hdmiOutput = pPlatformConfig->outputs.hdmi[portId];
        BKNI_Free(pPlatformConfig);

        if (hdmiOutput != NULL) {
            for (loops = 0; loops < 4; loops++) {
                rc = NEXUS_HdmiOutput_GetStatus(hdmiOutput, &status);
                if ((rc == NEXUS_SUCCESS) && status.connected) {
                    break;
                }
                ALOGV("%s: Waiting for HDMI%d output to be connected...", __PRETTY_FUNCTION__, portId);
                usleep(250 * 1000);
            }
        }

        if (rc == NEXUS_SUCCESS) {
            if (status.connected) {
                pHdmiOutputStatus->connected            = status.connected;
                pHdmiOutputStatus->rxPowered            = status.rxPowered;
                pHdmiOutputStatus->hdmiDevice           = status.hdmiDevice;
                pHdmiOutputStatus->videoFormat          = status.videoFormat;
                pHdmiOutputStatus->preferredVideoFormat = status.preferredVideoFormat;
                pHdmiOutputStatus->aspectRatio          = status.aspectRatio;
                pHdmiOutputStatus->colorSpace           = status.colorSpace;
                pHdmiOutputStatus->audioFormat          = status.audioFormat;
                pHdmiOutputStatus->audioSamplingRate    = status.audioSamplingRate;
                pHdmiOutputStatus->audioSamplingSize    = status.audioSamplingSize;
                pHdmiOutputStatus->audioChannelCount    = status.audioChannelCount;
                pHdmiOutputStatus->physicalAddress[0]   = status.physicalAddressA << 4 | status.physicalAddressB;
                pHdmiOutputStatus->physicalAddress[1]   = status.physicalAddressC << 4 | status.physicalAddressD;
            }
        }
        else {
            ALOGE("%s: Could not get HDMI%d output status!!!", __PRETTY_FUNCTION__, portId);
        }
    }
    else
#endif
    {
        ALOGE("%s: No HDMI%d output on this device!!!", __PRETTY_FUNCTION__, portId);
    }
    return (rc == NEXUS_SUCCESS);
}

bool NexusService::sendCecMessage(unsigned cecId, uint8_t srcAddr, uint8_t destAddr, size_t length, uint8_t *pMessage, uint8_t maxRetries)
{
    bool success = false;

    if (mCecServiceManager[cecId].get() != NULL && mCecServiceManager[cecId]->isPlatformInitialised()) {
        success = (mCecServiceManager[cecId]->sendCecMessage(srcAddr, destAddr, length, pMessage, maxRetries) == OK) ? true : false;
    }

    if (!success) {
        ALOGE("%s: Could not send CEC%d message opcode: 0x%02X!", __PRETTY_FUNCTION__, cecId, *pMessage);
    }
    return success;
}

bool NexusService::setPowerState(b_powerState pmState)
{
    NEXUS_Error rc = NEXUS_SUCCESS;
    NEXUS_PlatformStandbySettings nexusStandbySettings;

    if (pmState != powerState) {
        NEXUS_Platform_GetStandbySettings(&nexusStandbySettings);
        nexusStandbySettings.wakeupSettings.ir = 1;
        nexusStandbySettings.wakeupSettings.uhf = 1;
        nexusStandbySettings.wakeupSettings.transport = 1;
        nexusStandbySettings.wakeupSettings.cec = isCecEnabled(0) && isCecAutoWakeupEnabled(0);
        nexusStandbySettings.wakeupSettings.gpio = 1;
        nexusStandbySettings.wakeupSettings.timeout = 0;

        switch (pmState)
        {
            case ePowerState_S0:
            {
                ALOGD("%s: About to set power state S0...", __PRETTY_FUNCTION__);
                nexusStandbySettings.mode = NEXUS_PlatformStandbyMode_eOn;
                rc = NEXUS_Platform_SetStandbySettings(&nexusStandbySettings);
                break;
            }

            case ePowerState_S05:
            {
                ALOGD("%s: About to set power state S0.5...", __PRETTY_FUNCTION__);
                nexusStandbySettings.mode = NEXUS_PlatformStandbyMode_eOn;
                rc = NEXUS_Platform_SetStandbySettings(&nexusStandbySettings);
                break;
            }

            case ePowerState_S1:
            {
                ALOGD("%s: About to set power state S1...", __PRETTY_FUNCTION__);
                nexusStandbySettings.mode = NEXUS_PlatformStandbyMode_eActive;
                rc = NEXUS_Platform_SetStandbySettings(&nexusStandbySettings);
                break;
            }

            case ePowerState_S2:
            {
                ALOGD("%s: About to set power state S2...", __PRETTY_FUNCTION__);
                nexusStandbySettings.mode = NEXUS_PlatformStandbyMode_ePassive;
                rc = NEXUS_Platform_SetStandbySettings(&nexusStandbySettings);
                break;
            }

            case ePowerState_S3:
            case ePowerState_S5:
            {
                ALOGD("%s: About to set power state %s...", __PRETTY_FUNCTION__, NexusService::getPowerString(pmState));
                nexusStandbySettings.mode = NEXUS_PlatformStandbyMode_eDeepSleep;
                rc = NEXUS_Platform_SetStandbySettings(&nexusStandbySettings);
                break;
            }

            default:
            {
                ALOGE("%s: invalid power state %d!", __PRETTY_FUNCTION__, pmState);
                rc = NEXUS_INVALID_PARAMETER;
                break;
            }
        }
    }

    if (rc == NEXUS_SUCCESS) {
        powerState = pmState;
        return true;
    } else {
        ALOGE("%s: ERROR setting power state to %s!", __PRETTY_FUNCTION__, NexusService::getPowerString(pmState));
        return false;
    }
}

b_powerState NexusService::getPowerState()
{
    return powerState;
}

const char *NexusService::getPowerString(b_powerState pmState)
{
    switch (pmState) {
        case ePowerState_S0:
            return "S0";
        case ePowerState_S05:
            return "S0.5";
        case ePowerState_S1:
            return "S1";
        case ePowerState_S2:
            return "S2";
        case ePowerState_S3:
            return "S3";
        case ePowerState_S4:
            return "S4";
        case ePowerState_S5:
            return "S5";
        default:
            ALOGE("%s: Invalid power state %d!!!", __FUNCTION__, pmState);
            return "";
    }
}

status_t NexusService::setHdmiCecMessageEventListener(uint32_t cecId, const sp<INexusHdmiCecMessageEventListener> &listener)
{
    status_t status = INVALID_OPERATION;

    ALOGV("%s: CEC%d listener=%p", __PRETTY_FUNCTION__, cecId, listener.get());

    if (mCecServiceManager[cecId].get() != NULL) {
        status = mCecServiceManager[cecId]->setEventListener(listener);
    }

    if (status != OK) {
        ALOGE("%s: Could not set CEC%d message listener!", __PRETTY_FUNCTION__, cecId);
    }
    return status;
}

status_t NexusService::addHdmiHotplugEventListener(uint32_t portId, const sp<INexusHdmiHotplugEventListener> &listener)
{
    return INVALID_OPERATION;
}

status_t NexusService::removeHdmiHotplugEventListener(uint32_t portId, const sp<INexusHdmiHotplugEventListener>& listener)
{
    return INVALID_OPERATION;
}

void NexusService::binderDied(const wp<IBinder>& who)
{
#if NEXUS_HAS_HDMI_OUTPUT
    IBinder *binder = who.unsafe_get();
    if (binder != NULL) {
        Vector<sp<INexusHdmiHotplugEventListener> >::iterator it;

        Mutex::Autolock autoLock(server->mLock);

        for (unsigned portId = 0; portId < NEXUS_NUM_HDMI_OUTPUTS; portId++) {
            for (it = server->mHdmiHotplugEventListenerList[portId].begin(); it != server->mHdmiHotplugEventListenerList[portId].end(); ++it) {
                if ((*it)->asBinder() == binder) {
                    ALOGD("%s: Removing HDMI%d hotplug event listener...", __PRETTY_FUNCTION__, portId);
                    server->mHdmiHotplugEventListenerList[portId].erase(it);
                    return;
                }
            }
        }
    }
#endif
}

#undef CHECK_INTERFACE
#define CHECK_INTERFACE(interface, data, reply) \
        do { if (!data.enforceInterface(interface::getInterfaceDescriptor())) { \
            ALOGE("Call incorrectly routed to " #interface); \
            return PERMISSION_DENIED;              \
        } } while (0)

status_t NexusService::onTransact(uint32_t code,
                                  const Parcel &data,
                                  Parcel *reply,
                                  uint32_t flags)
{
    CHECK_INTERFACE(INexusService, data, reply);

    switch(code) {
    case API_OVER_BINDER: { /* braces are necessary when declaring variables within case: */
        int rc = 0;
        api_data cmd;
        data.read(&cmd, sizeof(cmd));

        switch(cmd.api)
        {
            case api_clientJoin:
            {
                cmd.param.clientJoin.out.clientHandle =
                    clientJoin(&cmd.param.clientJoin.in.clientName, &cmd.param.clientJoin.in.clientAuthenticationSettings);
                break;
            }
            case api_clientUninit:
            {
                cmd.param.clientUninit.out.status = clientUninit(cmd.param.clientUninit.in.clientHandle);
                break;
            }
            case api_createClientContext:
            {
                cmd.param.createClientContext.out.client = createClientContext(&cmd.param.createClientContext.in.clientName,
                                                                                cmd.param.createClientContext.in.clientPid);
                break;
            }
            case api_destroyClientContext:
            {
                destroyClientContext(cmd.param.destroyClientContext.in.client);
                break;
            }
            case api_setPowerState:
            {
                cmd.param.setPowerState.out.status = setPowerState(cmd.param.setPowerState.in.pmState);
                break;
            }
            case api_getPowerState:
            {
                cmd.param.getPowerState.out.pmState = getPowerState();
                break;
            }
            case api_setCecPowerState:
            {
                cmd.param.setCecPowerState.out.status = setCecPowerState(cmd.param.setCecPowerState.in.cecId,
                                                                         cmd.param.setCecPowerState.in.pmState);
                break;
            }
            case api_getCecPowerStatus:
            {
                cmd.param.getCecPowerStatus.out.status = getCecPowerStatus(cmd.param.getCecPowerStatus.in.cecId,
                                                                          &cmd.param.getCecPowerStatus.out.powerStatus);
                break;
            }
            case api_getCecStatus:
            {
                cmd.param.getCecStatus.out.status = getCecStatus(cmd.param.getCecStatus.in.cecId,
                                                                &cmd.param.getCecStatus.out.cecStatus);
                break;
            }
            case api_sendCecMessage:
            {
                cmd.param.sendCecMessage.out.status = sendCecMessage(cmd.param.sendCecMessage.in.cecId,
                                                                     cmd.param.sendCecMessage.in.srcAddr,
                                                                     cmd.param.sendCecMessage.in.destAddr,
                                                                     cmd.param.sendCecMessage.in.length,
                                                                     cmd.param.sendCecMessage.in.message,
                                                                     cmd.param.sendCecMessage.in.maxRetries);
                break;
            }
            case api_setCecLogicalAddress:
            {
                cmd.param.setCecLogicalAddress.out.status = setCecLogicalAddress(cmd.param.setCecLogicalAddress.in.cecId,
                                                                                 cmd.param.setCecLogicalAddress.in.addr);
                break;
            }
            case api_getHdmiOutputStatus:
            {
                cmd.param.getHdmiOutputStatus.out.status = getHdmiOutputStatus(cmd.param.getHdmiOutputStatus.in.portId,
                                                                              &cmd.param.getHdmiOutputStatus.out.hdmiOutputStatus);
                break;
            }
            default:
            {
                ALOGE("%s: Unhandled cmd = %d",__PRETTY_FUNCTION__,cmd.api);
                return INVALID_OPERATION;
            }
        } /* switch(cmd.api) */

        if(!rc)
        {
            reply->write(&cmd.param, sizeof(cmd.param));
            return NO_ERROR;
        }
        else
        {
            return FAILED_TRANSACTION;
        }
    } break; 

    case SET_HDMI_CEC_MESSAGE_EVENT_LISTENER: {
        uint32_t cecId = data.readInt32();
        sp<INexusHdmiCecMessageEventListener> listener = interface_cast<INexusHdmiCecMessageEventListener>(data.readStrongBinder());
        reply->writeInt32(setHdmiCecMessageEventListener(cecId, listener));
        return NO_ERROR;
    } break;

    case ADD_HDMI_HOTPLUG_EVENT_LISTENER: {
        uint32_t portId = data.readInt32();
        sp<INexusHdmiHotplugEventListener> listener = interface_cast<INexusHdmiHotplugEventListener>(data.readStrongBinder());
        reply->writeInt32(addHdmiHotplugEventListener(portId, listener));
        return NO_ERROR;
    } break;

    case REMOVE_HDMI_HOTPLUG_EVENT_LISTENER: {
        uint32_t portId = data.readInt32();
        sp<INexusHdmiHotplugEventListener> listener = interface_cast<INexusHdmiHotplugEventListener>(data.readStrongBinder());
        reply->writeInt32(removeHdmiHotplugEventListener(portId, listener));
        return NO_ERROR;
    } break;

    default:
        ALOGE("ERROR! No such transaction(%d) in nexus service", code);
        return BBinder::onTransact(code, data, reply, flags);
        break;
    }/* switch(code) */

    return NO_ERROR;
}
